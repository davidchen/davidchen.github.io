{"db":[{"meta":{"exported_on":1551243379904,"version":"2.5.0"},"data":{"api_keys":[],"app_fields":[],"app_settings":[],"apps":[],"brute":[{"key":"tQ/GoTyvHAkBnx4Q3TmEdiG4yQbqMayJcOx5i17jve0=","firstRequest":1549515110973,"lastRequest":1549515110973,"lifetime":1549518710976,"count":1}],"integrations":[],"invites":[],"migrations":[{"id":1,"name":"1-create-tables.js","version":"init","currentVersion":"2.5"},{"id":2,"name":"2-create-fixtures.js","version":"init","currentVersion":"2.5"},{"id":3,"name":"1-post-excerpt.js","version":"1.3","currentVersion":"2.5"},{"id":4,"name":"1-codeinjection-post.js","version":"1.4","currentVersion":"2.5"},{"id":5,"name":"1-og-twitter-post.js","version":"1.5","currentVersion":"2.5"},{"id":6,"name":"1-add-backup-client.js","version":"1.7","currentVersion":"2.5"},{"id":7,"name":"1-add-permissions-redirect.js","version":"1.9","currentVersion":"2.5"},{"id":8,"name":"1-custom-template-post.js","version":"1.13","currentVersion":"2.5"},{"id":9,"name":"2-theme-permissions.js","version":"1.13","currentVersion":"2.5"},{"id":10,"name":"1-add-webhooks-table.js","version":"1.18","currentVersion":"2.5"},{"id":11,"name":"1-webhook-permissions.js","version":"1.19","currentVersion":"2.5"},{"id":12,"name":"1-remove-settings-keys.js","version":"1.20","currentVersion":"2.5"},{"id":13,"name":"1-add-contributor-role.js","version":"1.21","currentVersion":"2.5"},{"id":14,"name":"1-multiple-authors-DDL.js","version":"1.22","currentVersion":"2.5"},{"id":15,"name":"1-multiple-authors-DML.js","version":"1.22","currentVersion":"2.5"},{"id":16,"name":"1-update-koenig-beta-html.js","version":"1.25","currentVersion":"2.5"},{"id":17,"name":"2-demo-post.js","version":"1.25","currentVersion":"2.5"},{"id":18,"name":"1-rename-amp-column.js","version":"2.0","currentVersion":"2.5"},{"id":19,"name":"2-update-posts.js","version":"2.0","currentVersion":"2.5"},{"id":20,"name":"3-remove-koenig-labs.js","version":"2.0","currentVersion":"2.5"},{"id":21,"name":"4-permalink-setting.js","version":"2.0","currentVersion":"2.5"},{"id":22,"name":"5-remove-demo-post.js","version":"2.0","currentVersion":"2.5"},{"id":23,"name":"6-replace-fixture-posts.js","version":"2.0","currentVersion":"2.5"},{"id":24,"name":"1-add-sessions-table.js","version":"2.2","currentVersion":"2.5"},{"id":25,"name":"2-add-integrations-and-api-key-tables.js","version":"2.2","currentVersion":"2.5"},{"id":26,"name":"3-insert-admin-integration-role.js","version":"2.2","currentVersion":"2.5"},{"id":27,"name":"4-insert-integration-and-api-key-permissions.js","version":"2.2","currentVersion":"2.5"},{"id":28,"name":"5-add-mobiledoc-revisions-table.js","version":"2.2","currentVersion":"2.5"},{"id":29,"name":"1-add-webhook-columns.js","version":"2.3","currentVersion":"2.5"},{"id":30,"name":"2-add-webhook-edit-permission.js","version":"2.3","currentVersion":"2.5"}],"migrations_lock":[{"lock_key":"km01","locked":0,"acquired_at":"2018-11-07T19:35:40.000Z","released_at":"2018-11-07T19:35:46.000Z"}],"mobiledoc_revisions":[{"id":"5be78ccd9686370eba85dc5b","post_id":"5be78bb59686370eba85dc50","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"####Introduction\\nFacebook recently introduced a whole new range of [Instant Games](https://messenger.fb.com/blog/instant-games-now-on-messenger/) that can be played in their Messenger app, whether on your mobile device or on your desktop. Naturally, the ubiquitous introduction of these mini-games have caused every one of my group chats on Messenger to become filled with friends savagely competing for the best scores. The more popular of these games include *Endless Lake* and *Track and Field 100M*. The purpose of *Endless Lake* is to avoid gaps in the path that your character takes by single and double tapping in order for your sprite to jump, whereas *Track and Field 100M* challenges you to make your track star finish the race as fast as possible by quickly tapping the screen in succession.\\n\\n####The problem\\nThe problem is simple: how do we get to the top of the scoreboard without legitimately playing the game? In other words, how can we hack and exploit the way these games communicate with the Facebook servers that keep track and tally the scores of each player?\\n\\n####The other problem\\nThere's a moral dilemma in hacking anything. On one hand, you're essentially saving yourself a butt-load of time and stress by simply gaming the system, platform, protocol, what-have-you, and finding alternative methods of achieving what many people believe to be success. On the other hand, you have officially become the asshole of the group chat for doing this because it's entirely not fair for the legitimate players who actually do try very hard to get on the leaderboard. I try my hardest not to be that asshole but sometimes having fun should not turn into a debate of morality. Try your best not to lose friends in the heat of the moment, and all should be fine. Onwards!\\n\\n####Networking\\nThe first task is to find out exactly how the game conveys the end score to Facebook's servers. This is easily accomplished using [Chrome's network developer tool](https://developers.google.com/web/tools/chrome-devtools/network-performance/resource-loading). From here, we're able to observe, filter, and record any and all network activity, including requests, flowing to and from your browser. We clear all network activity before we start up one of our games and set it to record immediately before the final score is sent to their servers (either upon your character's death or the finish of the race, respectively). The results are as follows:<br>\\n![](/content/images/2017/06/network.jpg)<br>\\nFrom this one recorded session, there were 109 requests made. Most of these were for images (.png, .jpeg) files which contained thumbnails of other games and Facebook friends. However, the name of the .xhr files starting with \\\"?doc_id\\\" and \\\"graphqlbatch\\\" are of interest, as these are the only plausible ways that the servers could be receiving some kind of data (.xhr is short for XMLHttpRequest, which is an API used by a variety of languages used to transfer and modify XML data using HTTP between client and server). Looking at the preview of the first .xhr file, we see something promising: payload data.<br>\\n![](/content/images/2017/06/network2.jpg)<br>\\nThis payload holds all the information regarding a player, their current score, their leaderboard, their friend's leaderboards, etc. This is most likely the data that we're trying to manipulate before it's sent to the server for validation and insertion. Just to be sure, we take a look at the headers of this request.<br>\\n![](/content/images/2017/06/network3.jpg)<br>\\nWe run the request URL through a generic URL decoder, and separate out the parameters given in order to get the following data:\\n<br>\\n```javascript\\ndoc_id=903271543141302  \\nvariables={\\\"data\\\":{  \\n    \\\"client_mutation_id\\\":\\\"0\\\",\\n    \\\"actor_id\\\":\\\"100000189902487\\\",\\n    \\\"game_id\\\":\\\"611307059053310\\\",\\n    \\\"score\\\":11,\\n    \\\"thread_id\\\":\\\"100000189902487\\\",\\n    \\\"story_id\\\":null,\\n    \\\"group_id\\\":null,\\n    \\\"send_admin\\\":false,\\n    \\\"session_id\\\":\\\"cf45dd18-0e1b-4bd8-b388-62913bdf75b3\\\"\\n}}\\ndpr=1  \\n```\\nNow it's quite clear to see that this request is indeed sending information about the exact game, score, group chat, and other key pieces of data to their endpoint at `https://www.messenger.com/webgraphql/mutation/`. Of course, one might think to simply make a copy of this request and send it along, with just a slight modification to the variable `score`. But this requires too much work; we'd have to get the request headers and query string parameters just right, and we're not too entirely sure if the `session_id` acts as an access token such that each one is uniquely generated to prevent this type of malicious request/score modification. Right, so now we know how the game is communicating with the servers and that it may be using some kind of key to prevent bad or unauthorized requests. This means we need to work with the request that the game generates naturally. How, then, do we stop the *original* request, modify it, and send it along again?\\n\\n####More Networking\\nThe answer to the previous question can be discovered with a simple Google search for \\\"http modify request\\\". One of these tools is called TamperChrome, and is an add-on/app for Chrome that lets users approve, modify, or decline requests as they are received. In other words, if the game had a phone and dialed Facebook to let them know the score a user received, TamperChrome acts as a redirected circuit on that phone line—it takes the data that was supposed to go directly to the server, modifies it, and sends it along as if nothing ever happened to it. Facebook's servers gladly accept this score as legitimate because everything else about the request is intact, including whatever unique key may have been generated. Running TamperChrome, we modify our score from a pathetic 11 points to an impressive 4011 points and approve this request to be sent along to the server.<br>\\n![](/content/images/2017/06/network-score-change.jpg)<br>\\n![](/content/images/2017/06/network-score-change2.jpg)<br>\\nThe changes are immediate: I've been catapulted to the top of the leaderboards:<br>\\n![](/content/images/2017/06/network-score-change3-new.jpg)<br>\\nRemember: with great power comes great responsibility. Please use this hack with that in mind.\"}]],\"sections\":[[10,0]]}","created_at_ts":1541901517042,"created_at":"2018-11-11T01:58:37.000Z"},{"id":"5be78ccd9686370eba85dc5c","post_id":"5be78bb59686370eba85dc50","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"####Introduction\\nFacebook recently introduced a whole new range of [Instant Games](https://messenger.fb.com/blog/instant-games-now-on-messenger/) that can be played in their Messenger app, whether on your mobile device or on your desktop. Naturally, the ubiquitous introduction of these mini-games have caused every one of my group chats on Messenger to become filled with friends savagely competing for the best scores. The more popular of these games include *Endless Lake* and *Track and Field 100M*. The purpose of *Endless Lake* is to avoid gaps in the path that your character takes by single and double tapping in order for your sprite to jump, whereas *Track and Field 100M* challenges you to make your track star finish the race as fast as possible by quickly tapping the screen in succession.\\n\\n####The problem\\nThe problem is simple: how do we get to the top of the scoreboard without legitimately playing the game? In other words, how can we hack and exploit the way these games communicate with the Facebook servers that keep track and tally the scores of each player?\\n\\n####The other problem\\nThere's a moral dilemma in hacking anything. On one hand, you're essentially saving yourself a butt-load of time and stress by simply gaming the system, platform, protocol, what-have-you, and finding alternative methods of achieving what many people believe to be success. On the other hand, you have officially become the asshole of the group chat for doing this because it's entirely not fair for the legitimate players who actually do try very hard to get on the leaderboard. I try my hardest not to be that asshole but sometimes having fun should not turn into a debate of morality. Try your best not to lose friends in the heat of the moment, and all should be fine. Onwards!\\n\\n####Networking\\nThe first task is to find out exactly how the game conveys the end score to Facebook's servers. This is easily accomplished using [Chrome's network developer tool](https://developers.google.com/web/tools/chrome-devtools/network-performance/resource-loading). From here, we're able to observe, filter, and record any and all network activity, including requests, flowing to and from your browser. We clear all network activity before we start up one of our games and set it to record immediately before the final score is sent to their servers (either upon your character's death or the finish of the race, respectively). The results are as follows:\\n<br>\\n![](/content/images/2017/06/network.jpg)<br>\\nFrom this one recorded session, there were 109 requests made. Most of these were for images (.png, .jpeg) files which contained thumbnails of other games and Facebook friends. However, the name of the .xhr files starting with \\\"?doc_id\\\" and \\\"graphqlbatch\\\" are of interest, as these are the only plausible ways that the servers could be receiving some kind of data (.xhr is short for XMLHttpRequest, which is an API used by a variety of languages used to transfer and modify XML data using HTTP between client and server). Looking at the preview of the first .xhr file, we see something promising: payload data.<br>\\n![](/content/images/2017/06/network2.jpg)<br>\\nThis payload holds all the information regarding a player, their current score, their leaderboard, their friend's leaderboards, etc. This is most likely the data that we're trying to manipulate before it's sent to the server for validation and insertion. Just to be sure, we take a look at the headers of this request.<br>\\n![](/content/images/2017/06/network3.jpg)<br>\\nWe run the request URL through a generic URL decoder, and separate out the parameters given in order to get the following data:\\n<br>\\n```javascript\\ndoc_id=903271543141302  \\nvariables={\\\"data\\\":{  \\n    \\\"client_mutation_id\\\":\\\"0\\\",\\n    \\\"actor_id\\\":\\\"100000189902487\\\",\\n    \\\"game_id\\\":\\\"611307059053310\\\",\\n    \\\"score\\\":11,\\n    \\\"thread_id\\\":\\\"100000189902487\\\",\\n    \\\"story_id\\\":null,\\n    \\\"group_id\\\":null,\\n    \\\"send_admin\\\":false,\\n    \\\"session_id\\\":\\\"cf45dd18-0e1b-4bd8-b388-62913bdf75b3\\\"\\n}}\\ndpr=1  \\n```\\nNow it's quite clear to see that this request is indeed sending information about the exact game, score, group chat, and other key pieces of data to their endpoint at `https://www.messenger.com/webgraphql/mutation/`. Of course, one might think to simply make a copy of this request and send it along, with just a slight modification to the variable `score`. But this requires too much work; we'd have to get the request headers and query string parameters just right, and we're not too entirely sure if the `session_id` acts as an access token such that each one is uniquely generated to prevent this type of malicious request/score modification. Right, so now we know how the game is communicating with the servers and that it may be using some kind of key to prevent bad or unauthorized requests. This means we need to work with the request that the game generates naturally. How, then, do we stop the *original* request, modify it, and send it along again?\\n\\n####More Networking\\nThe answer to the previous question can be discovered with a simple Google search for \\\"http modify request\\\". One of these tools is called TamperChrome, and is an add-on/app for Chrome that lets users approve, modify, or decline requests as they are received. In other words, if the game had a phone and dialed Facebook to let them know the score a user received, TamperChrome acts as a redirected circuit on that phone line—it takes the data that was supposed to go directly to the server, modifies it, and sends it along as if nothing ever happened to it. Facebook's servers gladly accept this score as legitimate because everything else about the request is intact, including whatever unique key may have been generated. Running TamperChrome, we modify our score from a pathetic 11 points to an impressive 4011 points and approve this request to be sent along to the server.<br>\\n![](/content/images/2017/06/network-score-change.jpg)<br>\\n![](/content/images/2017/06/network-score-change2.jpg)<br>\\nThe changes are immediate: I've been catapulted to the top of the leaderboards:<br>\\n![](/content/images/2017/06/network-score-change3-new.jpg)<br>\\nRemember: with great power comes great responsibility. Please use this hack with that in mind.\"}]],\"markups\":[],\"sections\":[[10,0]]}","created_at_ts":1541901517043,"created_at":"2018-11-11T01:58:37.000Z"},{"id":"5be78d199686370eba85dc5d","post_id":"5be78bb59686370eba85dc50","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"####Introduction\\nFacebook recently introduced a whole new range of [Instant Games](https://messenger.fb.com/blog/instant-games-now-on-messenger/) that can be played in their Messenger app, whether on your mobile device or on your desktop. Naturally, the ubiquitous introduction of these mini-games have caused every one of my group chats on Messenger to become filled with friends savagely competing for the best scores. The more popular of these games include *Endless Lake* and *Track and Field 100M*. The purpose of *Endless Lake* is to avoid gaps in the path that your character takes by single and double tapping in order for your sprite to jump, whereas *Track and Field 100M* challenges you to make your track star finish the race as fast as possible by quickly tapping the screen in succession.\\n\\n####The problem\\nThe problem is simple: how do we get to the top of the scoreboard without legitimately playing the game? In other words, how can we hack and exploit the way these games communicate with the Facebook servers that keep track and tally the scores of each player?\\n\\n####The other problem\\nThere's a moral dilemma in hacking anything. On one hand, you're essentially saving yourself a butt-load of time and stress by simply gaming the system, platform, protocol, what-have-you, and finding alternative methods of achieving what many people believe to be success. On the other hand, you have officially become the asshole of the group chat for doing this because it's entirely not fair for the legitimate players who actually do try very hard to get on the leaderboard. I try my hardest not to be that asshole but sometimes having fun should not turn into a debate of morality. Try your best not to lose friends in the heat of the moment, and all should be fine. Onwards!\\n\\n####Networking\\nThe first task is to find out exactly how the game conveys the end score to Facebook's servers. This is easily accomplished using [Chrome's network developer tool](https://developers.google.com/web/tools/chrome-devtools/network-performance/resource-loading). From here, we're able to observe, filter, and record any and all network activity, including requests, flowing to and from your browser. We clear all network activity before we start up one of our games and set it to record immediately before the final score is sent to their servers (either upon your character's death or the finish of the race, respectively). The results are as follows:\\n\\n![](/content/images/2017/06/network.jpg)\\n\\nFrom this one recorded session, there were 109 requests made. Most of these were for images (.png, .jpeg) files which contained thumbnails of other games and Facebook friends. However, the name of the .xhr files starting with \\\"?doc_id\\\" and \\\"graphqlbatch\\\" are of interest, as these are the only plausible ways that the servers could be receiving some kind of data (.xhr is short for XMLHttpRequest, which is an API used by a variety of languages used to transfer and modify XML data using HTTP between client and server). Looking at the preview of the first .xhr file, we see something promising: payload data.\\n\\n![](/content/images/2017/06/network2.jpg)\\n\\nThis payload holds all the information regarding a player, their current score, their leaderboard, their friend's leaderboards, etc. This is most likely the data that we're trying to manipulate before it's sent to the server for validation and insertion. Just to be sure, we take a look at the headers of this request.<br>\\n![](/content/images/2017/06/network3.jpg)<br>\\nWe run the request URL through a generic URL decoder, and separate out the parameters given in order to get the following data:\\n<br>\\n```javascript\\ndoc_id=903271543141302  \\nvariables={\\\"data\\\":{  \\n    \\\"client_mutation_id\\\":\\\"0\\\",\\n    \\\"actor_id\\\":\\\"100000189902487\\\",\\n    \\\"game_id\\\":\\\"611307059053310\\\",\\n    \\\"score\\\":11,\\n    \\\"thread_id\\\":\\\"100000189902487\\\",\\n    \\\"story_id\\\":null,\\n    \\\"group_id\\\":null,\\n    \\\"send_admin\\\":false,\\n    \\\"session_id\\\":\\\"cf45dd18-0e1b-4bd8-b388-62913bdf75b3\\\"\\n}}\\ndpr=1  \\n```\\nNow it's quite clear to see that this request is indeed sending information about the exact game, score, group chat, and other key pieces of data to their endpoint at `https://www.messenger.com/webgraphql/mutation/`. Of course, one might think to simply make a copy of this request and send it along, with just a slight modification to the variable `score`. But this requires too much work; we'd have to get the request headers and query string parameters just right, and we're not too entirely sure if the `session_id` acts as an access token such that each one is uniquely generated to prevent this type of malicious request/score modification. Right, so now we know how the game is communicating with the servers and that it may be using some kind of key to prevent bad or unauthorized requests. This means we need to work with the request that the game generates naturally. How, then, do we stop the *original* request, modify it, and send it along again?\\n\\n####More Networking\\nThe answer to the previous question can be discovered with a simple Google search for \\\"http modify request\\\". One of these tools is called TamperChrome, and is an add-on/app for Chrome that lets users approve, modify, or decline requests as they are received. In other words, if the game had a phone and dialed Facebook to let them know the score a user received, TamperChrome acts as a redirected circuit on that phone line—it takes the data that was supposed to go directly to the server, modifies it, and sends it along as if nothing ever happened to it. Facebook's servers gladly accept this score as legitimate because everything else about the request is intact, including whatever unique key may have been generated. Running TamperChrome, we modify our score from a pathetic 11 points to an impressive 4011 points and approve this request to be sent along to the server.<br>\\n![](/content/images/2017/06/network-score-change.jpg)<br>\\n![](/content/images/2017/06/network-score-change2.jpg)<br>\\nThe changes are immediate: I've been catapulted to the top of the leaderboards:<br>\\n![](/content/images/2017/06/network-score-change3-new.jpg)<br>\\nRemember: with great power comes great responsibility. Please use this hack with that in mind.\"}]],\"markups\":[],\"sections\":[[10,0]]}","created_at_ts":1541901593543,"created_at":"2018-11-11T01:59:53.000Z"},{"id":"5be78d379686370eba85dc5e","post_id":"5be78bb59686370eba85dc50","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"####Introduction\\nFacebook recently introduced a whole new range of [Instant Games](https://messenger.fb.com/blog/instant-games-now-on-messenger/) that can be played in their Messenger app, whether on your mobile device or on your desktop. Naturally, the ubiquitous introduction of these mini-games have caused every one of my group chats on Messenger to become filled with friends savagely competing for the best scores. The more popular of these games include *Endless Lake* and *Track and Field 100M*. The purpose of *Endless Lake* is to avoid gaps in the path that your character takes by single and double tapping in order for your sprite to jump, whereas *Track and Field 100M* challenges you to make your track star finish the race as fast as possible by quickly tapping the screen in succession.\\n\\n####The problem\\nThe problem is simple: how do we get to the top of the scoreboard without legitimately playing the game? In other words, how can we hack and exploit the way these games communicate with the Facebook servers that keep track and tally the scores of each player?\\n\\n####The other problem\\nThere's a moral dilemma in hacking anything. On one hand, you're essentially saving yourself a butt-load of time and stress by simply gaming the system, platform, protocol, what-have-you, and finding alternative methods of achieving what many people believe to be success. On the other hand, you have officially become the asshole of the group chat for doing this because it's entirely not fair for the legitimate players who actually do try very hard to get on the leaderboard. I try my hardest not to be that asshole but sometimes having fun should not turn into a debate of morality. Try your best not to lose friends in the heat of the moment, and all should be fine. Onwards!\\n\\n####Networking\\nThe first task is to find out exactly how the game conveys the end score to Facebook's servers. This is easily accomplished using [Chrome's network developer tool](https://developers.google.com/web/tools/chrome-devtools/network-performance/resource-loading). From here, we're able to observe, filter, and record any and all network activity, including requests, flowing to and from your browser. We clear all network activity before we start up one of our games and set it to record immediately before the final score is sent to their servers (either upon your character's death or the finish of the race, respectively). The results are as follows:\\n\\n![](/content/images/2017/06/network.jpg)\\n\\nFrom this one recorded session, there were 109 requests made. Most of these were for images (.png, .jpeg) files which contained thumbnails of other games and Facebook friends. However, the name of the .xhr files starting with \\\"?doc_id\\\" and \\\"graphqlbatch\\\" are of interest, as these are the only plausible ways that the servers could be receiving some kind of data (.xhr is short for XMLHttpRequest, which is an API used by a variety of languages used to transfer and modify XML data using HTTP between client and server). Looking at the preview of the first .xhr file, we see something promising: payload data.\\n\\n![](/content/images/2017/06/network2.jpg)\\n\\nThis payload holds all the information regarding a player, their current score, their leaderboard, their friend's leaderboards, etc. This is most likely the data that we're trying to manipulate before it's sent to the server for validation and insertion. Just to be sure, we take a look at the headers of this request.<br>\\n![](/content/images/2017/06/network3.jpg)<br>\\nWe run the request URL through a generic URL decoder, and separate out the parameters given in order to get the following data:\\n\\n```javascript\\ndoc_id=903271543141302  \\nvariables={\\\"data\\\":{  \\n    \\\"client_mutation_id\\\":\\\"0\\\",\\n    \\\"actor_id\\\":\\\"100000189902487\\\",\\n    \\\"game_id\\\":\\\"611307059053310\\\",\\n    \\\"score\\\":11,\\n    \\\"thread_id\\\":\\\"100000189902487\\\",\\n    \\\"story_id\\\":null,\\n    \\\"group_id\\\":null,\\n    \\\"send_admin\\\":false,\\n    \\\"session_id\\\":\\\"cf45dd18-0e1b-4bd8-b388-62913bdf75b3\\\"\\n}}\\ndpr=1  \\n```\\n\\nNow it's quite clear to see that this request is indeed sending information about the exact game, score, group chat, and other key pieces of data to their endpoint at `https://www.messenger.com/webgraphql/mutation/`. Of course, one might think to simply make a copy of this request and send it along, with just a slight modification to the variable `score`. But this requires too much work; we'd have to get the request headers and query string parameters just right, and we're not too entirely sure if the `session_id` acts as an access token such that each one is uniquely generated to prevent this type of malicious request/score modification. Right, so now we know how the game is communicating with the servers and that it may be using some kind of key to prevent bad or unauthorized requests. This means we need to work with the request that the game generates naturally. How, then, do we stop the *original* request, modify it, and send it along again?\\n\\n####More Networking\\nThe answer to the previous question can be discovered with a simple Google search for \\\"http modify request\\\". One of these tools is called TamperChrome, and is an add-on/app for Chrome that lets users approve, modify, or decline requests as they are received. In other words, if the game had a phone and dialed Facebook to let them know the score a user received, TamperChrome acts as a redirected circuit on that phone line—it takes the data that was supposed to go directly to the server, modifies it, and sends it along as if nothing ever happened to it. Facebook's servers gladly accept this score as legitimate because everything else about the request is intact, including whatever unique key may have been generated. Running TamperChrome, we modify our score from a pathetic 11 points to an impressive 4011 points and approve this request to be sent along to the server.\\n\\n![](/content/images/2017/06/network-score-change.jpg)\\n\\n![](/content/images/2017/06/network-score-change2.jpg)\\n\\nThe changes are immediate: I've been catapulted to the top of the leaderboards:\\n\\n![](/content/images/2017/06/network-score-change3-new.jpg)\\n\\nRemember: with great power comes great responsibility. Please use this hack with that in mind.\"}]],\"markups\":[],\"sections\":[[10,0]]}","created_at_ts":1541901623097,"created_at":"2018-11-11T02:00:23.000Z"},{"id":"5be78daf9686370eba85dc5f","post_id":"5be78bb59686370eba85dc51","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"####Selenium WebDriver\\n\\nSelenium has always been one of the most popular and robust ways to automate browser-based work and testing. There are a variety of methods used for element selection when using the Selenium WebDriver. Consider the following snippet that creates an instance of Chrome and browses to the Amazon front page and gathers every link it can find:\\n<br>\\n```python\\n# filename: profiler_test.py\\nfrom selenium import webdriver\\n\\nCHROME_DRIVER_PATH = 'chromedriver.exe'\\n\\n\\ndef main():  \\n    d = webdriver.Chrome()\\n\\n    d.get(\\\"https://www.amazon.com\\\")\\n    d.maximize_window()\\n    get_all_pages_links(d)\\n    d.quit()\\n\\n\\ndef get_all_pages_links(d):  \\n    hrefs = []\\n    links = d.find_elements_by_tag_name('a')\\n    for link in links:\\n        href = link.get_attribute('href')\\n        hrefs.append(href)\\n    return hrefs\\n\\n\\nif __name__ == '__main__':  \\n    main()\\n```\\nThis is the page we are seeing by the way:<br>\\n![](/content/images/2017/06/amazon.jpg)\\n\\n####Line Profiling\\nNow the question is, how long did it take us to get the `href` for every `a` tag present on this page? If you're curious, there were 428 total links present on this page alone. That is a lot of searching for Selenium's `find_elements_by_tag_name()` to do. One way to determine how fast our code is running is by using something called a [line profiler](https://www.huyng.com/posts/python-performance-analysis). We add a `@profile` decorator to both `main()` and `get_all_pages_links()` before running our profiler. Via the command line, we run the test with the command `kernprof.exe -l -v profiler_test.py`. Testing this with a profiler, the results are:\\n<br>\\n```bash\\nWrote profile results to profiler_test.py.lprof  \\nTimer unit: 4.26667e-07 s\\n\\nTotal time: 15.8145 s  \\nFile: profiler_test.py  \\nFunction: main at line 8\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n     8                                           @profile\\n     9                                           def main():\\n    10         1      8780838 8780838.0     23.7      d = webdriver.Chrome()\\n    11\\n    12         1      2672345 2672345.0      7.2      d.get(\\\"https://www.amazon.com\\\")\\n    13         1      2871840 2871840.0      7.7      d.maximize_window()\\n    14         1     15225302 15225302.0     41.1      get_all_pages_links(d)\\n    15         1      7514945 7514945.0     20.3      d.quit()\\n\\nTotal time: 6.49449 s  \\nFile: profiler_test.py  \\nFunction: get_all_pages_links at line 18\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n    18                                           @profile\\n    19                                           def get_all_pages_links(d):\\n    20         1            3      3.0      0.0      hrefs = []\\n    21         1      3620538 3620538.0     23.8      links = d.find_elements_by_tag_name('a')\\n    22       428         1198      2.8      0.0      for link in links:\\n    23       427     11595822  27156.5     76.2          href = link.get_attribute('href')\\n    24       427         3875      9.1      0.0          hrefs.append(href)\\n    25         1            1      1.0      0.0      return hrefs\\n```\\nWe see that it took nearly 15.8 seconds for the Chrome instance to start, to navigate to the Amazon page, to gather all links, and then to quit. What was the longest part of this runtime? It was line 23, the one where we ask for each a tag's `href`. In fact, this gathering of `href` values account for 76% of our runtime within the `get_all_pages_links()` function (about 4.94 seconds or more than one-fourth of the total script runtime). This is far too long in terms of automatic web testing. Imagine you needed to gather all links from hundreds and thousands of web pages? The process would take hours for even simple websites.\\n\\n####Utilizing XPath\\nHow can we do better? What other functions can we call from our webdriver.Chrome class such that we can make finding tags and their attributes faster? What if we tried to find all the a tags and their hrefs using XPath? Let's try it. Our code now looks like:\\n<br>\\n```python\\n# filename: profiler_test.py\\n\\nfrom selenium import webdriver\\n\\nCHROME_DRIVER_PATH = 'chromedriver.exe'\\n\\n\\n@profile\\ndef main():  \\n    d = webdriver.Chrome()\\n\\n    d.get(\\\"https://www.amazon.com\\\")\\n    d.maximize_window()\\n    get_all_pages_links(d)\\n    d.quit()\\n\\n\\n@profile\\ndef get_all_pages_links(d):  \\n    hrefs = []\\n    links = d.find_elements_by_xpath('//a')\\n    for link in links:\\n        href = link.get_attribute('href')\\n        hrefs.append(href)\\n    return hrefs\\n\\n\\nif __name__ == '__main__':  \\n    main()\\n```\\nAnd the results from running with the profiler:\\n<br>\\n```bash\\nWrote profile results to profiler_test.py.lprof  \\nTimer unit: 4.26667e-07 s\\n\\nTotal time: 16.262 s  \\nFile: profiler_test.py  \\nFunction: main at line 8\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n     8                                           @profile\\n     9                                           def main():\\n    10         1      8203882 8203882.0     21.5      d = webdriver.Chrome()\\n    11\\n    12         1      8535178 8535178.0     22.4      d.get(\\\"https://www.amazon.com\\\")\\n    13         1      2910691 2910691.0      7.6      d.maximize_window()\\n    14         1     10979849 10979849.0     28.8      get_all_pages_links(d)\\n    15         1      7484319 7484319.0     19.6      d.quit()\\n\\nTotal time: 4.68298 s  \\nFile: profiler_test.py  \\nFunction: get_all_pages_links at line 18\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n    18                                           @profile\\n    19                                           def get_all_pages_links(d):\\n    20         1            3      3.0      0.0      hrefs = []\\n    21         1       317767 317767.0      2.9      links = d.find_elements_by_xpath('//a')\\n    22       431         1092      2.5      0.0      for link in links:\\n    23       430     10652981  24774.4     97.1          href = link.get_attribute('href')\\n    24       430         3875      9.0      0.0          hrefs.append(href)\\n    25         1            2      2.0      0.0      return hrefs\\n```\\nThe same gathering operation now takes around 4.5 seconds. This is an improvement of about half a second. Although good, this is not helpful in the bigger picture. We need these links, and we need them fast. So here's one last idea.\\n\\n####Scripts Within Scripts\\nSelenium WebDrivers have a function called `execute_script()`, which as the name implies injects (JavaScript) code into the browser and returns whatever result that the code does. How about we check to see if directly injecting such a code is faster at getting all the page's links when compared to using `get_attribute()`? The raw JavaScript code to retrieve all page `href` values is coded as such:\\n<br>\\n```javascript\\nfunction get_all_hrefs() {  \\n    var anchors = document.links;\\n    var hrefs = [];\\n    for (var i=0; i<anchors .length; i++) {\\n        hrefs.push(anchors[i].href);\\n    }\\n\\n    return hrefs;\\n}\\n```\\nWe re-write `profiler_test.py` to use this function:\\n<br>\\n```python\\n# filename: profiler_test.py\\n\\nfrom selenium import webdriver\\n\\nCHROME_DRIVER_PATH = 'chromedriver.exe'\\n\\nJS_GET_ALL_HREFS = r'''function get_all_hrefs() {  \\n    var anchors = document.links;\\n    var hrefs = [];\\n    for (var i=0; i<anchors .length; i++) {\\n        hrefs.push(anchors[i].href);\\n    }\\n\\n    return hrefs;\\n}\\nreturn get_all_hrefs();  \\n'''\\n\\n@profile\\ndef main():  \\n    d = webdriver.Chrome()\\n\\n    d.get(\\\"https://www.amazon.com\\\")\\n    d.maximize_window()\\n    get_all_pages_links(d)\\n    d.quit()\\n\\n\\n@profile\\ndef get_all_pages_links(d):  \\n    hrefs = d.execute_script(JS_GET_ALL_HREFS)\\n    return hrefs\\n\\n\\nif __name__ == '__main__':  \\n    main()\\n```\\nAnd lastly, we test with the line profiler:\\n<br>\\n```bash\\nWrote profile results to profiler_test.py.lprof  \\nTimer unit: 4.26667e-07 s\\n\\nTotal time: 10.4917 s  \\nFile: profiler_test.py  \\nFunction: main at line 19\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n    19                                           @profile\\n    20                                           def main():\\n    21         1      8136920 8136920.0     33.1      d = webdriver.Chrome()\\n    22\\n    23         1      5377998 5377998.0     21.9      d.get(\\\"https://www.amazon.com\\\")\\n    24         1      2888695 2888695.0     11.7      d.maximize_window()\\n    25         1       203765 203765.0      0.8      H = get_all_pages_links(d)\\n    26       451         4658     10.3      0.0      for h in H:\\n    27       450       489150   1087.0      2.0          print(h)\\n    28         1      7488800 7488800.0     30.5      d.quit()\\n\\nTotal time: 0.0868468 s  \\nFile: profiler_test.py  \\nFunction: get_all_pages_links at line 31\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n    31                                           @profile\\n    32                                           def get_all_pages_links(d):\\n    33         1       203523 203523.0    100.0      hrefs = d.execute_script(JS_GET_ALL_HREFS)\\n    34         1           24     24.0      0.0      return hrefs\\n```\\nThe results speak for themselves. The runtime of `get_all_pages_links()` went from 6.49 seconds to 4.68 seconds to **0.086 seconds**. We improved the time needed to scrape all the page's links by a **factor of more than 75**. These results demonstrate the power of line profiling and how it can be used to drastically improve runtimes. Testing each type of function in a case by case basis lets developers know exactly which ones will run most efficiently so that they can create faster and more robust automated tests. In this case, the links were able to scraped in an alternative way such that we had to go through one less layer of abstraction. Instead of using the Selenium library within Python to access browser elements, we use JavaScript to access those elements much more quickly, and then simply send the results back to our library for processing. By cutting out the middleman, we save time and computational power.\"}]],\"sections\":[[10,0]]}","created_at_ts":1541901743711,"created_at":"2018-11-11T02:02:23.000Z"},{"id":"5be78daf9686370eba85dc60","post_id":"5be78bb59686370eba85dc51","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"####Selenium WebDriver\\n\\nSelenium has always been one of the most popular and robust ways to automate browser-based work and testing. There are a variety of methods used for element selection when using the Selenium WebDriver. Consider the following snippet that creates an instance of Chrome and browses to the Amazon front page and gathers every link it can find:\\n\\n```python\\n# filename: profiler_test.py\\nfrom selenium import webdriver\\n\\nCHROME_DRIVER_PATH = 'chromedriver.exe'\\n\\n\\ndef main():  \\n    d = webdriver.Chrome()\\n\\n    d.get(\\\"https://www.amazon.com\\\")\\n    d.maximize_window()\\n    get_all_pages_links(d)\\n    d.quit()\\n\\n\\ndef get_all_pages_links(d):  \\n    hrefs = []\\n    links = d.find_elements_by_tag_name('a')\\n    for link in links:\\n        href = link.get_attribute('href')\\n        hrefs.append(href)\\n    return hrefs\\n\\n\\nif __name__ == '__main__':  \\n    main()\\n```\\n\\nThis is the page we are seeing by the way:\\n\\n![](/content/images/2017/06/amazon.jpg)\\n\\n####Line Profiling\\nNow the question is, how long did it take us to get the `href` for every `a` tag present on this page? If you're curious, there were 428 total links present on this page alone. That is a lot of searching for Selenium's `find_elements_by_tag_name()` to do. One way to determine how fast our code is running is by using something called a [line profiler](https://www.huyng.com/posts/python-performance-analysis). We add a `@profile` decorator to both `main()` and `get_all_pages_links()` before running our profiler. Via the command line, we run the test with the command `kernprof.exe -l -v profiler_test.py`. Testing this with a profiler, the results are:\\n\\n```bash\\nWrote profile results to profiler_test.py.lprof  \\nTimer unit: 4.26667e-07 s\\n\\nTotal time: 15.8145 s  \\nFile: profiler_test.py  \\nFunction: main at line 8\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n     8                                           @profile\\n     9                                           def main():\\n    10         1      8780838 8780838.0     23.7      d = webdriver.Chrome()\\n    11\\n    12         1      2672345 2672345.0      7.2      d.get(\\\"https://www.amazon.com\\\")\\n    13         1      2871840 2871840.0      7.7      d.maximize_window()\\n    14         1     15225302 15225302.0     41.1      get_all_pages_links(d)\\n    15         1      7514945 7514945.0     20.3      d.quit()\\n\\nTotal time: 6.49449 s  \\nFile: profiler_test.py  \\nFunction: get_all_pages_links at line 18\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n    18                                           @profile\\n    19                                           def get_all_pages_links(d):\\n    20         1            3      3.0      0.0      hrefs = []\\n    21         1      3620538 3620538.0     23.8      links = d.find_elements_by_tag_name('a')\\n    22       428         1198      2.8      0.0      for link in links:\\n    23       427     11595822  27156.5     76.2          href = link.get_attribute('href')\\n    24       427         3875      9.1      0.0          hrefs.append(href)\\n    25         1            1      1.0      0.0      return hrefs\\n```\\n\\nWe see that it took nearly 15.8 seconds for the Chrome instance to start, to navigate to the Amazon page, to gather all links, and then to quit. What was the longest part of this runtime? It was line 23, the one where we ask for each a tag's `href`. In fact, this gathering of `href` values account for 76% of our runtime within the `get_all_pages_links()` function (about 4.94 seconds or more than one-fourth of the total script runtime). This is far too long in terms of automatic web testing. Imagine you needed to gather all links from hundreds and thousands of web pages? The process would take hours for even simple websites.\\n\\n####Utilizing XPath\\nHow can we do better? What other functions can we call from our webdriver.Chrome class such that we can make finding tags and their attributes faster? What if we tried to find all the a tags and their hrefs using XPath? Let's try it. Our code now looks like:\\n\\n```python\\n# filename: profiler_test.py\\n\\nfrom selenium import webdriver\\n\\nCHROME_DRIVER_PATH = 'chromedriver.exe'\\n\\n\\n@profile\\ndef main():  \\n    d = webdriver.Chrome()\\n\\n    d.get(\\\"https://www.amazon.com\\\")\\n    d.maximize_window()\\n    get_all_pages_links(d)\\n    d.quit()\\n\\n\\n@profile\\ndef get_all_pages_links(d):  \\n    hrefs = []\\n    links = d.find_elements_by_xpath('//a')\\n    for link in links:\\n        href = link.get_attribute('href')\\n        hrefs.append(href)\\n    return hrefs\\n\\n\\nif __name__ == '__main__':  \\n    main()\\n```\\n\\nAnd the results from running with the profiler:\\n\\n```bash\\nWrote profile results to profiler_test.py.lprof  \\nTimer unit: 4.26667e-07 s\\n\\nTotal time: 16.262 s  \\nFile: profiler_test.py  \\nFunction: main at line 8\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n     8                                           @profile\\n     9                                           def main():\\n    10         1      8203882 8203882.0     21.5      d = webdriver.Chrome()\\n    11\\n    12         1      8535178 8535178.0     22.4      d.get(\\\"https://www.amazon.com\\\")\\n    13         1      2910691 2910691.0      7.6      d.maximize_window()\\n    14         1     10979849 10979849.0     28.8      get_all_pages_links(d)\\n    15         1      7484319 7484319.0     19.6      d.quit()\\n\\nTotal time: 4.68298 s  \\nFile: profiler_test.py  \\nFunction: get_all_pages_links at line 18\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n    18                                           @profile\\n    19                                           def get_all_pages_links(d):\\n    20         1            3      3.0      0.0      hrefs = []\\n    21         1       317767 317767.0      2.9      links = d.find_elements_by_xpath('//a')\\n    22       431         1092      2.5      0.0      for link in links:\\n    23       430     10652981  24774.4     97.1          href = link.get_attribute('href')\\n    24       430         3875      9.0      0.0          hrefs.append(href)\\n    25         1            2      2.0      0.0      return hrefs\\n```\\n\\nThe same gathering operation now takes around 4.5 seconds. This is an improvement of about half a second. Although good, this is not helpful in the bigger picture. We need these links, and we need them fast. So here's one last idea.\\n\\n####Scripts Within Scripts\\nSelenium WebDrivers have a function called `execute_script()`, which as the name implies injects (JavaScript) code into the browser and returns whatever result that the code does. How about we check to see if directly injecting such a code is faster at getting all the page's links when compared to using `get_attribute()`? The raw JavaScript code to retrieve all page `href` values is coded as such:\\n\\n```javascript\\nfunction get_all_hrefs() {  \\n    var anchors = document.links;\\n    var hrefs = [];\\n    for (var i=0; i<anchors .length; i++) {\\n        hrefs.push(anchors[i].href);\\n    }\\n\\n    return hrefs;\\n}\\n```\\n\\nWe re-write `profiler_test.py` to use this function:\\n\\n```python\\n# filename: profiler_test.py\\n\\nfrom selenium import webdriver\\n\\nCHROME_DRIVER_PATH = 'chromedriver.exe'\\n\\nJS_GET_ALL_HREFS = r'''function get_all_hrefs() {  \\n    var anchors = document.links;\\n    var hrefs = [];\\n    for (var i=0; i<anchors .length; i++) {\\n        hrefs.push(anchors[i].href);\\n    }\\n\\n    return hrefs;\\n}\\nreturn get_all_hrefs();  \\n'''\\n\\n@profile\\ndef main():  \\n    d = webdriver.Chrome()\\n\\n    d.get(\\\"https://www.amazon.com\\\")\\n    d.maximize_window()\\n    get_all_pages_links(d)\\n    d.quit()\\n\\n\\n@profile\\ndef get_all_pages_links(d):  \\n    hrefs = d.execute_script(JS_GET_ALL_HREFS)\\n    return hrefs\\n\\n\\nif __name__ == '__main__':  \\n    main()\\n```\\n\\nAnd lastly, we test with the line profiler:\\n\\n```bash\\nWrote profile results to profiler_test.py.lprof  \\nTimer unit: 4.26667e-07 s\\n\\nTotal time: 10.4917 s  \\nFile: profiler_test.py  \\nFunction: main at line 19\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n    19                                           @profile\\n    20                                           def main():\\n    21         1      8136920 8136920.0     33.1      d = webdriver.Chrome()\\n    22\\n    23         1      5377998 5377998.0     21.9      d.get(\\\"https://www.amazon.com\\\")\\n    24         1      2888695 2888695.0     11.7      d.maximize_window()\\n    25         1       203765 203765.0      0.8      H = get_all_pages_links(d)\\n    26       451         4658     10.3      0.0      for h in H:\\n    27       450       489150   1087.0      2.0          print(h)\\n    28         1      7488800 7488800.0     30.5      d.quit()\\n\\nTotal time: 0.0868468 s  \\nFile: profiler_test.py  \\nFunction: get_all_pages_links at line 31\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n    31                                           @profile\\n    32                                           def get_all_pages_links(d):\\n    33         1       203523 203523.0    100.0      hrefs = d.execute_script(JS_GET_ALL_HREFS)\\n    34         1           24     24.0      0.0      return hrefs\\n```\\n\\nThe results speak for themselves. The runtime of `get_all_pages_links()` went from 6.49 seconds to 4.68 seconds to **0.086 seconds**. We improved the time needed to scrape all the page's links by a **factor of more than 75**. These results demonstrate the power of line profiling and how it can be used to drastically improve runtimes. Testing each type of function in a case by case basis lets developers know exactly which ones will run most efficiently so that they can create faster and more robust automated tests. In this case, the links were able to scraped in an alternative way such that we had to go through one less layer of abstraction. Instead of using the Selenium library within Python to access browser elements, we use JavaScript to access those elements much more quickly, and then simply send the results back to our library for processing. By cutting out the middleman, we save time and computational power.\"}]],\"markups\":[],\"sections\":[[10,0]]}","created_at_ts":1541901743712,"created_at":"2018-11-11T02:02:23.000Z"},{"id":"5c5bbbc35d0d6b08c557fff8","post_id":"5c5bbbc35d0d6b08c557fff6","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[],\"sections\":[[1,\"p\",[[0,[],0,\"\"]]]]}","created_at_ts":1549515715281,"created_at":"2019-02-07T05:01:55.000Z"},{"id":"5c5bbbc95d0d6b08c557fff9","post_id":"5c5bbbc35d0d6b08c557fff6","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"The problems below were posed by my *Design and Analysis of Algorithms* professor. Although we did not spend much time on the solution or its implications, I figured over-analyzing it might be in order if I wanted to read back on this in the future and think of the productivity wasted on this post.\\n\\n#### The initial problem\\nGiven a special candle of unknown length that burns up in one hour regardless of the orientation it is placed in (i.e. whether the candle is lit upside down or right side up or some other degree of rotation), how can you use this candle as a timer to know when 30 minutes have passed? The density of the candle's wax varies along the whole length, so two equal lengths will burn up in different times (you aren't allowed to measure the length of the candle anyway). Assume the wick is present on both ends of the candle (meaning you can light two fires at once), and that you are able to light a fire or split the candle with no loss of relative time. Remember: you need the timer to start immediately, so the goal is to use the candle as a timer, not to be left with a candle timer. This is a variation of the [burning rope problem](https://curiosity.com/topics/the-burning-rope-logic-puzzle/) but uses the more environmentally conscious alternative to setting ropes on fire: burning candles.\\n\\n#### The initial solution\\nLight both ends of the candle. It is trivial to see how we can measure 30 minutes using a single candle and two fires. Regardless of how long the candle is, we simply need the information that the whole candle will burn in one hour; this means that the amount of wax present is only able to fuel one hour of burn time with one fire going. Thus, burning two fires using both ends of the candle means using the same amount of fuel but twice as fast. Therefore, once the two fires meet and the candle runs out of wax, 30 minutes have passed.\\n\\n#### Blackouts are inconvenient\\nSay you found a stash of more one-hour candles. What if you had the same problem as above, but now wanted to measure 45 minutes? We already know how to achieve 30 minutes using one candle, so going for 45 minutes with two candles should not be a tall order. The solution is as follows: light the two ends of the first candle as above, but also light one end of a second candle. Once the first candle burns out in 30 minutes, we are left with 30 minutes remaining on the second burning candle. Light the unlit end in order to get this candle to use fuel twice as fast, so that it burns out in 15 minutes. This gives us 45 minutes of total light we wanted.\\n\\nWhat happens if we wanted to get 15 minutes using only one candle? Turns out, this is the hardest of the problems encountered so far. Since we only have one candle, it'd be impossible to get any amount of time less than 30 minutes without having to split the candle into two or more parts. Thus, the solution lies in breaking this one candle into two pieces of candle. The non-intuitive part of it all is that the length of the two pieces do not matter in this solution. In fact, length does not play a role in finding the solution to any amount of time, which is why the seemingly unknown length is irrelevant to the whole thing. We now have two (unequal) child parts of the same candle. The first step of the solution is to light both ends of both candles, so that there are 4 fires burning at the same time. You can sort of see a pattern now: one fire equals an hour of light, two fires give half that time, etc. The caveat to burning four fires is knowing what to do after the first of the two pairs of fires burn out earlier than the other (which it will, as the two unequal pieces imply that one has to be shorter). The solution is simple: the moment the first child candle burn out, take the other candle and split it into two child pieces again, and make sure both ends are lit for each. Since we are assuming there is no wasted time in splitting candles and lighting fires, the candles will all eventually burn out completely in 15 minutes. Simply explained, the whole candle will burn out in 15 minutes because you will always have four fires burning simultaneously. This is similar to the 30 minutes solution: at any time, your candle will be burning two fires, so it runs out of fuel twice as fast. In this solution, your candle is running out of fuel 4 times as fast, and therefore your fuel lasts a fourth of an hour. In general, if you had multiple children candles, you split a remaining candle every time one of them burns out in order to maintain the same number of fires alive to consume the total fuel.\\n\\nThe table below shows the general pattern of parts and fires needed to achieve a given burning time in minutes for one candle. Parts, in this case, means the number of parts you are splitting the initial candle into, and does not account for the times you recursively break up the child candles.\\n\\n<table>\\n  <tr>\\n    <th>Parts</th>\\n    <th>Fires</th> \\n    <th>Time</th>\\n  </tr>\\n  <tr>\\n    <td>1</td>\\n    <td>1</td> \\n    <td>60</td>\\n  </tr>\\n  <tr>\\n    <td>1</td>\\n    <td>2</td> \\n    <td>30</td>\\n  </tr>\\n  <tr>\\n    <td>2</td>\\n    <td>3</td> \\n    <td>20</td>\\n  </tr>\\n  <tr>\\n    <td>2</td>\\n    <td>4</td> \\n    <td>15</td>\\n  </tr>\\n  <tr>\\n    <td>3</td>\\n    <td>5</td> \\n    <td>12</td>\\n  </tr>\\n  <tr>\\n    <td>3</td>\\n    <td>6</td> \\n    <td>10</td>\\n  </tr>\\n</table>\\n\\n#### What time is it?\\nThe general equation for the number of fires $f$ needed to achieve a time $t$ in minutes is then simply $f=\\\\frac{60}t$. The number of parts $p$ needed given $f$ is then $p=\\\\lceil\\\\frac{f}2 \\\\rceil$. Keep in mind that this equation is valid only if we have one candle, and therefore $f\\\\in\\\\mathbb{Z^+}$. If such is the case, then the only exact times we are able to achieve with one candle are the quotients of dividing 60 by any positive integer. We can say that given a candle that normally burns (with a single flame) in $m$ minutes, the set of all solutions are in $\\\\\\\\{\\\\frac mz \\\\mid z\\\\in\\\\mathbb{Z^+}\\\\\\\\}$. So, knowing how the solution plays out, and how long one candle burns for, let's write a simple Python script to calculate how many parts the initial candle needs to be split into, and how many fires need to be simultaneously lit in order to achieve a desired time. We have two arguments to pass in: `burn_rate` (the time it takes to burn the whole candle with a single fire) and `target_time` (a time you'd like to waste playing with candles). The program should output a tuple: the former number will be the parts to split into and the latter will be the number of fires to light between all those parts. These two pieces of information will get you as close to your `target_time` as possible without exceeding it. The code below demonstrates one way of achieving this.\\n\\n```language-python\\nimport math\\n\\ndef candle_waster(burn_rate, target_time):\\n  fires = math.ceil(burn_rate/target_time)\\n  parts = math.ceil(fires/2)\\n  if target_time > burn_rate:\\n    return \\\"Can't burn candle longer than burn_rate\\\"\\n  return parts, fires\\n    \\nprint(candle_waster(60,15))\\nprint(candle_waster(30,5))\\nprint(candle_waster(10,1))\\nprint(candle_waster(5,3))\\nprint(candle_waster(1,2))\\n```\\n```language-none\\n(2, 4)\\n(3, 6)\\n(5, 10)\\n(1, 2)\\nCan't burn candle longer than burn_rate\\n```\\nThat was the easier part. Let's figure out what times we're able to achieve with more than one candle.\\n\\n#### Lots and lots of wax\\n\\nSuppose now we have two candles that all have the same burn rate of $m$ minutes each. It is simple to see that we are able to achieve a maximum time of $2m$ minutes by using them in succession&mdash;that is, burning them one by one until we're done. In fact, these \\\"additive\\\" times are reached simply by adding any times $t\\\\_1$ and $t\\\\_2$ together such that $t\\\\_1, t\\\\_2 \\\\in S$, where $S = \\\\\\\\{\\\\frac mz \\\\mid z\\\\in\\\\mathbb{Z^+}\\\\\\\\}$ (the set of times possible with each candle of burn rate $m$). One can see that $\\\\lvert S \\\\rvert = \\\\infty$ because we haven't defined proper constraints for $z$. For our sake, we can define a maximum number of fires $e$ allowed for each candle (meaning no one candle can have more than $e$ fires ablaze at one time, which limits the magnitude of $S$ to a finite number). Furthermore, let's define $S\\\\_{m,e}$ to mean **the set of times achievable with a single candle of burn rate $m$ and max fires of $e$**:\\n$$\\nS\\\\_{m,e} = \\\\\\\\{\\\\frac mz \\\\mid z\\\\in\\\\mathbb{Z^+}, 1 \\\\leq z \\\\leq e \\\\\\\\}\\n$$\\nAs an example, set $m=60, e=3$. Thus, the two candles are able to produce the times in $S\\\\_{60,3}$ *individually*. This means that, by itself, any one of the two candles can produce any of these times in the set $S\\\\_{60,3} = \\\\\\\\{60,30,20\\\\\\\\}$. Utilizing both of them, however, produces a wider range of possible times.\\n\\n---\\n\\nThe set of possible times of using *both* candles is expanded because you have more choices as to how you go about lighting, splitting, and delaying each candle. One set of possibilities is the option of successively lighting each candle after the last one burns out. Let's call this set of times $T\\\\_{sc}$. In our example above, each candle is able to burn for either 60, 30, or 20 minutes each. We see that if we burn the first candle for 60 minutes, *then* burn the second for 60 minutes, we've produced a new possible time of 120 minutes. Each of the times in $S\\\\_{60,3}$ is added to all possible times also in the same set $S\\\\_{60,3}$. As such, we are left with $T\\\\_{sc}$ containing the set of numbers which result from the [Minkowski addition](https://en.wikipedia.org/wiki/Minkowski_addition) (or direct sum) of $S\\\\_{60,3}$ and itself. It's intuitive to see how the times form from successive burning, and we demonstrate it below with all possible cases of said process. Let the first and second candles, along with their remaining burn times, be $c\\\\_{1},c\\\\_{2},b\\\\_{1},b\\\\_{2}$, respectively.\\n\\nSuccessive burning:\\n\\n* (Case 1) $c\\\\_{1}$ burns for $b\\\\_{1}=60$ minutes, then\\n    * (1A) $c\\\\_{2}$ burns for $b\\\\_{2}=60$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 120 minutes.\\n    * (1B) $c\\\\_{2}$ burns for $b\\\\_{2}=30$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 90 minutes.\\n    * (1C) $c\\\\_{2}$ burns for $b\\\\_{2}=20$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 80 minutes.\\n\\n* (Case 2) $c\\\\_{1}$ burns for $b\\\\_{1}=30$ minutes, then\\n    * (2A) $c\\\\_{2}$ burns for $b\\\\_{2}=60$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 90 minutes.\\n    * (2B) $c\\\\_{2}$ burns for $b\\\\_{2}=30$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 60 minutes.\\n    * (2C) $c\\\\_{2}$ burns for $b\\\\_{2}=20$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 50 minutes.\\n\\n* (Case 3) $c\\\\_{1}$ burns for $b\\\\_{1}=20$ minutes, then\\n    * (3A) $c\\\\_{2}$ burns for $b\\\\_{2}=60$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 80 minutes.\\n    * (3B) $c\\\\_{2}$ burns for $b\\\\_{2}=30$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 50 minutes.\\n    * (3C) $c\\\\_{2}$ burns for $b\\\\_{2}=20$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 40 minutes.\\n\\nThus, $T\\\\_{sc} = \\\\\\\\{120,90,80,60,50,40\\\\\\\\}$ given two candles, with $m=60, e=3$. The other option of discovering time possibilities is the idea of simultaneously burning the candles. This method is a bit trickier. Recall that towards the start of this post was a solution for 45 minutes that involved two candles: the first candle was lit on one end and the second was lit on both ends. Both burned for 30 minutes (until the second one burned out) and the first one was left with 30 remaining minutes of wax (30 minutes have also passed at this point). We ensured the remaining one had two fires ablaze and thus burned twice as fast with 30 minutes of fuel left, which means it burned for 15 minutes. The 30 minutes from the simultaneous burning and the 15 from the remainder burning produced 45 total minutes. This was possible because we were able to reduce the first candle's burn rate down by any attainable time of the second candle, and from there we solved the sub-problem of getting 15 minutes using an $m=30$ candle. Let $T\\\\_{sim}$ be the set of times that result from simultaneously burning both candles and adding on the time possibility set of the remaining candle. Each case of these simultaneously burnings are outline below.\\n\\nSimultaneous (then remainder) burning:\\n\\n* (Case 1) Light $c\\\\_{1}$ with 1 fire ($b\\\\_{1}=60$) along with\\n    * (1A) $c\\\\_{2}$ with 1 fire ($b\\\\_{2}=60$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=0$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 60+\\\\\\\\{0\\\\\\\\} = \\\\\\\\{60\\\\\\\\}$\\n    * (1B) $c\\\\_{2}$ with 2 fires ($b\\\\_{2}=30$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=30$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 30+\\\\\\\\{30,15,10\\\\\\\\} = \\\\\\\\{60,45,40\\\\\\\\}$\\n    * (1C) $c\\\\_{2}$ with 3 fires ($b\\\\_{2}=20$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=40$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 20+\\\\\\\\{40,20,\\\\frac{40}3\\\\\\\\} = \\\\\\\\{60,40,33\\\\frac13\\\\\\\\}$\\n\\n* (Case 2) Light $c\\\\_{1}$ with 2 fires ($b\\\\_{1}=30$) along with\\n    * (2A) $c\\\\_{2}$ with 1 fire ($b\\\\_{2}=60$) $\\\\rightarrow$ same as case 1B.\\n    * (2B) $c\\\\_{2}$ with 2 fires ($b\\\\_{2}=30$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=0$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 30+\\\\\\\\{0\\\\\\\\} = \\\\\\\\{30\\\\\\\\}$\\n    * (2C) $c\\\\_{2}$ with 3 fires ($b\\\\_{2}=20$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=10$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 20+\\\\\\\\{10,5,\\\\frac{10}3\\\\\\\\} = \\\\\\\\{30,25,23\\\\frac13\\\\\\\\}$\\n\\n* (Case 3) Light $c\\\\_{1}$ with 3 fires ($b\\\\_{1}=20$) along with\\n    * (3A) $c\\\\_{2}$ with 1 fire ($b\\\\_{2}=60$) $\\\\rightarrow$ same as case 1C.\\n    * (3B) $c\\\\_{2}$ with 2 fires ($b\\\\_{2}=30$) $\\\\rightarrow$ same as case 2C.\\n    * (3C) $c\\\\_{2}$ with 3 fires ($b\\\\_{2}=20$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=0$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 20+\\\\\\\\{0\\\\\\\\} = \\\\\\\\{20\\\\\\\\}$\\n\\nThus, $T\\\\_{sim} = \\\\\\\\{60,45,40,33\\\\frac13,30,25,23\\\\frac13,20\\\\\\\\}$ given two candles, with $m=60, e=3$. We have then that given these two candles, we're about to produce the final set of times $T$:\\n$$\\nT = S\\\\_{60,3} \\\\cup T\\\\_{sc} \\\\cup T\\\\_{sim}=\\\\\\\\{120,90,80,60,50,45,40,33\\\\frac13,30,25,23\\\\frac13,20\\\\\\\\}\\n$$\\nNow, what would happen with three candles? The short story is, the successive times of three candles with the same burn rate and max fires is simply the direct sum of our previous times of 2 candles $T$ with another $S\\\\_{60,3}$. Similarly, the possible simultaneous times of this group would utilize the same procedure we used for $S\\\\_{60,3}$, except now we find all possible cases using the expanded set of times $T$ instead. Let's define a few functions back in Python to help us figure out all the times given a number of `candles`, a `burn_rate`, and `max_fires`. The function `times_succession()` accepts two sets and returns the direct sum of those two sets. The function `times_simul()` accepts two sets and max fires, and returns the set of times as described in our simultaneous and remainder burning above. `times_of_one_candle()` simply returns the set of times possible with one candle given its burn rate and max fires.\\n\\n```language-python\\ndef times_succession(set_one, set_two):\\n    t_sc = set([])\\n\\n    for x in set_one:\\n        for y in set_two:\\n            t_sc |= {round(x + y, 4)}\\n\\n    return t_sc\\n\\n\\ndef times_simul(set_one, set_two, max_fires):\\n    t_sim = set([])\\n\\n    for x in set_one:\\n        for y in set_two:\\n            if x >= y:\\n                remaining_time = x - y\\n                t = times_succession({round(y, 4)}, times_of_one_candle(remaining_time, max_fires))\\n                t_sim |= t\\n\\n    return t_sim\\n\\n\\ndef times_of_one_candle(burn_rate, max_fires):\\n    s = set([])\\n\\n    for x in range(1, max_fires + 1):\\n        s |= {burn_rate / x}\\n\\n    return s\\n```\\n\\nWe now have functions that return all the subsets needed for our equation in order to find all the possible sets given the correct parameters. Let's write a function `all_times()`, which takes in our three arguments `candles`, `burn_rate`, and `max_fires` and calls our helper functions to return the set of all times that we are able to achieve with these constraints.\\n\\n```language-python\\ndef all_times(candles, burn_rate, max_fires):\\n    if candles == 0 or burn_rate == 0 or max_fires == 0:\\n        return set([])\\n    if candles == 1:\\n        return times_of_one_candle(burn_rate, max_fires)\\n\\n    times = set([])\\n\\n    s = times_of_one_candle(burn_rate, max_fires)\\n    times |= s\\n\\n    for c in range(1, candles):\\n        t_sc = times_succession(times, s)\\n        t_sim = times_simul(times, s, max_fires)\\n        times |= (t_sc | t_sim)\\n\\n    return times\\n\\ns = sorted(all_times(2, 60, 3), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n    \\ns = sorted(all_times(3, 60, 4), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n    \\ns = sorted(all_times(4, 100, 5), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n    \\ns = sorted(all_times(5, 100, 6), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n    \\ns = sorted(all_times(6, 200, 5), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n```\\n```language-none\\n[120.0, 90.0, 80.0, 60.0, 50.0, 45.0, 40.0, 33.3333, 30.0, 25.0, 23.3333, 20.0]\\nMagnitude: 12\\n[180.0, 150.0, 140.0, 120.0, 110.0, 105.0, 100.0, 93.3333, 90.0, 85.0, 83.3333, ...]\\nMagnitude: 100\\n[400.0, 350.0, 333.3333, 325.0, 300.0, 283.3333, 275.0, 266.6667, 266.6666, ...]\\nMagnitude: 2414\\n[500.0, 450.0, 433.3333, 425.0, 420.0, 400.0, 383.3333, 375.0, 370.0, 366.6667, ...]\\nMagnitude: 30885\\n[1200.0, 1100.0, 1066.6667, 1050.0, 1040.0, 1000.0, 966.6667, 950.0, 940.0, ...]\\nMagnitude: 75430\\n```\\n\\nThe magnitude of each set displayed is simply the number of possible times. At this point, it's trivial to search for a time goal by reversing the process such that the script gives us `candles`, `burn_rate`, and/or `max_fires` given an input time goal.\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]]}","created_at_ts":1549515721374,"created_at":"2019-02-07T05:02:01.000Z"},{"id":"5c5bbcb65d0d6b08c557ffff","post_id":"5be78bb59686370eba85dc50","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"Facebook recently introduced a whole new range of [Instant Games](https://messenger.fb.com/blog/instant-games-now-on-messenger/) that can be played in their Messenger app, whether on your mobile device or on your desktop.\\n\\n####Introduction\\nNaturally, the ubiquitous introduction of these mini-games have caused every one of my group chats on Messenger to become filled with friends savagely competing for the best scores. The more popular of these games include *Endless Lake* and *Track and Field 100M*. The purpose of *Endless Lake* is to avoid gaps in the path that your character takes by single and double tapping in order for your sprite to jump, whereas *Track and Field 100M* challenges you to make your track star finish the race as fast as possible by quickly tapping the screen in succession.\\n\\n####The problem\\nThe problem is simple: how do we get to the top of the scoreboard without legitimately playing the game? In other words, how can we hack and exploit the way these games communicate with the Facebook servers that keep track and tally the scores of each player?\\n\\n####The other problem\\nThere's a moral dilemma in hacking anything. On one hand, you're essentially saving yourself a butt-load of time and stress by simply gaming the system, platform, protocol, what-have-you, and finding alternative methods of achieving what many people believe to be success. On the other hand, you have officially become the asshole of the group chat for doing this because it's entirely not fair for the legitimate players who actually do try very hard to get on the leaderboard. I try my hardest not to be that asshole but sometimes having fun should not turn into a debate of morality. Try your best not to lose friends in the heat of the moment, and all should be fine. Onwards!\\n\\n####Networking\\nThe first task is to find out exactly how the game conveys the end score to Facebook's servers. This is easily accomplished using [Chrome's network developer tool](https://developers.google.com/web/tools/chrome-devtools/network-performance/resource-loading). From here, we're able to observe, filter, and record any and all network activity, including requests, flowing to and from your browser. We clear all network activity before we start up one of our games and set it to record immediately before the final score is sent to their servers (either upon your character's death or the finish of the race, respectively). The results are as follows:\\n\\n![](/content/images/2017/06/network.jpg)\\n\\nFrom this one recorded session, there were 109 requests made. Most of these were for images (.png, .jpeg) files which contained thumbnails of other games and Facebook friends. However, the name of the .xhr files starting with \\\"?doc_id\\\" and \\\"graphqlbatch\\\" are of interest, as these are the only plausible ways that the servers could be receiving some kind of data (.xhr is short for XMLHttpRequest, which is an API used by a variety of languages used to transfer and modify XML data using HTTP between client and server). Looking at the preview of the first .xhr file, we see something promising: payload data.\\n\\n![](/content/images/2017/06/network2.jpg)\\n\\nThis payload holds all the information regarding a player, their current score, their leaderboard, their friend's leaderboards, etc. This is most likely the data that we're trying to manipulate before it's sent to the server for validation and insertion. Just to be sure, we take a look at the headers of this request.<br>\\n![](/content/images/2017/06/network3.jpg)<br>\\nWe run the request URL through a generic URL decoder, and separate out the parameters given in order to get the following data:\\n\\n```javascript\\ndoc_id=903271543141302  \\nvariables={\\\"data\\\":{  \\n    \\\"client_mutation_id\\\":\\\"0\\\",\\n    \\\"actor_id\\\":\\\"100000189902487\\\",\\n    \\\"game_id\\\":\\\"611307059053310\\\",\\n    \\\"score\\\":11,\\n    \\\"thread_id\\\":\\\"100000189902487\\\",\\n    \\\"story_id\\\":null,\\n    \\\"group_id\\\":null,\\n    \\\"send_admin\\\":false,\\n    \\\"session_id\\\":\\\"cf45dd18-0e1b-4bd8-b388-62913bdf75b3\\\"\\n}}\\ndpr=1  \\n```\\n\\nNow it's quite clear to see that this request is indeed sending information about the exact game, score, group chat, and other key pieces of data to their endpoint at `https://www.messenger.com/webgraphql/mutation/`. Of course, one might think to simply make a copy of this request and send it along, with just a slight modification to the variable `score`. But this requires too much work; we'd have to get the request headers and query string parameters just right, and we're not too entirely sure if the `session_id` acts as an access token such that each one is uniquely generated to prevent this type of malicious request/score modification. Right, so now we know how the game is communicating with the servers and that it may be using some kind of key to prevent bad or unauthorized requests. This means we need to work with the request that the game generates naturally. How, then, do we stop the *original* request, modify it, and send it along again?\\n\\n####More Networking\\nThe answer to the previous question can be discovered with a simple Google search for \\\"http modify request\\\". One of these tools is called TamperChrome, and is an add-on/app for Chrome that lets users approve, modify, or decline requests as they are received. In other words, if the game had a phone and dialed Facebook to let them know the score a user received, TamperChrome acts as a redirected circuit on that phone line—it takes the data that was supposed to go directly to the server, modifies it, and sends it along as if nothing ever happened to it. Facebook's servers gladly accept this score as legitimate because everything else about the request is intact, including whatever unique key may have been generated. Running TamperChrome, we modify our score from a pathetic 11 points to an impressive 4011 points and approve this request to be sent along to the server.\\n\\n![](/content/images/2017/06/network-score-change.jpg)\\n\\n![](/content/images/2017/06/network-score-change2.jpg)\\n\\nThe changes are immediate: I've been catapulted to the top of the leaderboards:\\n\\n![](/content/images/2017/06/network-score-change3-new.jpg)\\n\\nRemember: with great power comes great responsibility. Please use this hack with that in mind.\"}]],\"markups\":[],\"sections\":[[10,0]]}","created_at_ts":1549515958267,"created_at":"2019-02-07T05:05:58.000Z"},{"id":"5c5bbce35d0d6b08c5580000","post_id":"5be78bb59686370eba85dc51","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"Selenium has always been one of the most popular and robust ways to automate browser-based work and testing. There are a variety of methods used for element selection when using the Selenium WebDriver. Consider the following snippet that creates an instance of Chrome and browses to the Amazon front page and gathers every link it can find:\\n\\n```python\\n# filename: profiler_test.py\\nfrom selenium import webdriver\\n\\nCHROME_DRIVER_PATH = 'chromedriver.exe'\\n\\n\\ndef main():  \\n    d = webdriver.Chrome()\\n\\n    d.get(\\\"https://www.amazon.com\\\")\\n    d.maximize_window()\\n    get_all_pages_links(d)\\n    d.quit()\\n\\n\\ndef get_all_pages_links(d):  \\n    hrefs = []\\n    links = d.find_elements_by_tag_name('a')\\n    for link in links:\\n        href = link.get_attribute('href')\\n        hrefs.append(href)\\n    return hrefs\\n\\n\\nif __name__ == '__main__':  \\n    main()\\n```\\n\\nThis is the page we are seeing by the way:\\n\\n![](/content/images/2017/06/amazon.jpg)\\n\\n####Line Profiling\\nNow the question is, how long did it take us to get the `href` for every `a` tag present on this page? If you're curious, there were 428 total links present on this page alone. That is a lot of searching for Selenium's `find_elements_by_tag_name()` to do. One way to determine how fast our code is running is by using something called a [line profiler](https://www.huyng.com/posts/python-performance-analysis). We add a `@profile` decorator to both `main()` and `get_all_pages_links()` before running our profiler. Via the command line, we run the test with the command `kernprof.exe -l -v profiler_test.py`. Testing this with a profiler, the results are:\\n\\n```bash\\nWrote profile results to profiler_test.py.lprof  \\nTimer unit: 4.26667e-07 s\\n\\nTotal time: 15.8145 s  \\nFile: profiler_test.py  \\nFunction: main at line 8\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n     8                                           @profile\\n     9                                           def main():\\n    10         1      8780838 8780838.0     23.7      d = webdriver.Chrome()\\n    11\\n    12         1      2672345 2672345.0      7.2      d.get(\\\"https://www.amazon.com\\\")\\n    13         1      2871840 2871840.0      7.7      d.maximize_window()\\n    14         1     15225302 15225302.0     41.1      get_all_pages_links(d)\\n    15         1      7514945 7514945.0     20.3      d.quit()\\n\\nTotal time: 6.49449 s  \\nFile: profiler_test.py  \\nFunction: get_all_pages_links at line 18\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n    18                                           @profile\\n    19                                           def get_all_pages_links(d):\\n    20         1            3      3.0      0.0      hrefs = []\\n    21         1      3620538 3620538.0     23.8      links = d.find_elements_by_tag_name('a')\\n    22       428         1198      2.8      0.0      for link in links:\\n    23       427     11595822  27156.5     76.2          href = link.get_attribute('href')\\n    24       427         3875      9.1      0.0          hrefs.append(href)\\n    25         1            1      1.0      0.0      return hrefs\\n```\\n\\nWe see that it took nearly 15.8 seconds for the Chrome instance to start, to navigate to the Amazon page, to gather all links, and then to quit. What was the longest part of this runtime? It was line 23, the one where we ask for each a tag's `href`. In fact, this gathering of `href` values account for 76% of our runtime within the `get_all_pages_links()` function (about 4.94 seconds or more than one-fourth of the total script runtime). This is far too long in terms of automatic web testing. Imagine you needed to gather all links from hundreds and thousands of web pages? The process would take hours for even simple websites.\\n\\n####Utilizing XPath\\nHow can we do better? What other functions can we call from our webdriver.Chrome class such that we can make finding tags and their attributes faster? What if we tried to find all the a tags and their hrefs using XPath? Let's try it. Our code now looks like:\\n\\n```python\\n# filename: profiler_test.py\\n\\nfrom selenium import webdriver\\n\\nCHROME_DRIVER_PATH = 'chromedriver.exe'\\n\\n\\n@profile\\ndef main():  \\n    d = webdriver.Chrome()\\n\\n    d.get(\\\"https://www.amazon.com\\\")\\n    d.maximize_window()\\n    get_all_pages_links(d)\\n    d.quit()\\n\\n\\n@profile\\ndef get_all_pages_links(d):  \\n    hrefs = []\\n    links = d.find_elements_by_xpath('//a')\\n    for link in links:\\n        href = link.get_attribute('href')\\n        hrefs.append(href)\\n    return hrefs\\n\\n\\nif __name__ == '__main__':  \\n    main()\\n```\\n\\nAnd the results from running with the profiler:\\n\\n```bash\\nWrote profile results to profiler_test.py.lprof  \\nTimer unit: 4.26667e-07 s\\n\\nTotal time: 16.262 s  \\nFile: profiler_test.py  \\nFunction: main at line 8\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n     8                                           @profile\\n     9                                           def main():\\n    10         1      8203882 8203882.0     21.5      d = webdriver.Chrome()\\n    11\\n    12         1      8535178 8535178.0     22.4      d.get(\\\"https://www.amazon.com\\\")\\n    13         1      2910691 2910691.0      7.6      d.maximize_window()\\n    14         1     10979849 10979849.0     28.8      get_all_pages_links(d)\\n    15         1      7484319 7484319.0     19.6      d.quit()\\n\\nTotal time: 4.68298 s  \\nFile: profiler_test.py  \\nFunction: get_all_pages_links at line 18\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n    18                                           @profile\\n    19                                           def get_all_pages_links(d):\\n    20         1            3      3.0      0.0      hrefs = []\\n    21         1       317767 317767.0      2.9      links = d.find_elements_by_xpath('//a')\\n    22       431         1092      2.5      0.0      for link in links:\\n    23       430     10652981  24774.4     97.1          href = link.get_attribute('href')\\n    24       430         3875      9.0      0.0          hrefs.append(href)\\n    25         1            2      2.0      0.0      return hrefs\\n```\\n\\nThe same gathering operation now takes around 4.5 seconds. This is an improvement of about half a second. Although good, this is not helpful in the bigger picture. We need these links, and we need them fast. So here's one last idea.\\n\\n####Scripts Within Scripts\\nSelenium WebDrivers have a function called `execute_script()`, which as the name implies injects (JavaScript) code into the browser and returns whatever result that the code does. How about we check to see if directly injecting such a code is faster at getting all the page's links when compared to using `get_attribute()`? The raw JavaScript code to retrieve all page `href` values is coded as such:\\n\\n```javascript\\nfunction get_all_hrefs() {  \\n    var anchors = document.links;\\n    var hrefs = [];\\n    for (var i=0; i<anchors .length; i++) {\\n        hrefs.push(anchors[i].href);\\n    }\\n\\n    return hrefs;\\n}\\n```\\n\\nWe re-write `profiler_test.py` to use this function:\\n\\n```python\\n# filename: profiler_test.py\\n\\nfrom selenium import webdriver\\n\\nCHROME_DRIVER_PATH = 'chromedriver.exe'\\n\\nJS_GET_ALL_HREFS = r'''function get_all_hrefs() {  \\n    var anchors = document.links;\\n    var hrefs = [];\\n    for (var i=0; i<anchors .length; i++) {\\n        hrefs.push(anchors[i].href);\\n    }\\n\\n    return hrefs;\\n}\\nreturn get_all_hrefs();  \\n'''\\n\\n@profile\\ndef main():  \\n    d = webdriver.Chrome()\\n\\n    d.get(\\\"https://www.amazon.com\\\")\\n    d.maximize_window()\\n    get_all_pages_links(d)\\n    d.quit()\\n\\n\\n@profile\\ndef get_all_pages_links(d):  \\n    hrefs = d.execute_script(JS_GET_ALL_HREFS)\\n    return hrefs\\n\\n\\nif __name__ == '__main__':  \\n    main()\\n```\\n\\nAnd lastly, we test with the line profiler:\\n\\n```bash\\nWrote profile results to profiler_test.py.lprof  \\nTimer unit: 4.26667e-07 s\\n\\nTotal time: 10.4917 s  \\nFile: profiler_test.py  \\nFunction: main at line 19\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n    19                                           @profile\\n    20                                           def main():\\n    21         1      8136920 8136920.0     33.1      d = webdriver.Chrome()\\n    22\\n    23         1      5377998 5377998.0     21.9      d.get(\\\"https://www.amazon.com\\\")\\n    24         1      2888695 2888695.0     11.7      d.maximize_window()\\n    25         1       203765 203765.0      0.8      H = get_all_pages_links(d)\\n    26       451         4658     10.3      0.0      for h in H:\\n    27       450       489150   1087.0      2.0          print(h)\\n    28         1      7488800 7488800.0     30.5      d.quit()\\n\\nTotal time: 0.0868468 s  \\nFile: profiler_test.py  \\nFunction: get_all_pages_links at line 31\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n    31                                           @profile\\n    32                                           def get_all_pages_links(d):\\n    33         1       203523 203523.0    100.0      hrefs = d.execute_script(JS_GET_ALL_HREFS)\\n    34         1           24     24.0      0.0      return hrefs\\n```\\n\\nThe results speak for themselves. The runtime of `get_all_pages_links()` went from 6.49 seconds to 4.68 seconds to **0.086 seconds**. We improved the time needed to scrape all the page's links by a **factor of more than 75**. These results demonstrate the power of line profiling and how it can be used to drastically improve runtimes. Testing each type of function in a case by case basis lets developers know exactly which ones will run most efficiently so that they can create faster and more robust automated tests. In this case, the links were able to scraped in an alternative way such that we had to go through one less layer of abstraction. Instead of using the Selenium library within Python to access browser elements, we use JavaScript to access those elements much more quickly, and then simply send the results back to our library for processing. By cutting out the middleman, we save time and computational power.\"}]],\"markups\":[],\"sections\":[[10,0]]}","created_at_ts":1549516003753,"created_at":"2019-02-07T05:06:43.000Z"},{"id":"5c5bbcff5d0d6b08c5580001","post_id":"5be78bb59686370eba85dc51","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"Selenium has always been one of the most popular and robust ways to automate browser-based work and testing. There are a variety of methods used for element selection when using the Selenium WebDriver.\\n\\n####Product Parsing\\nConsider the following snippet that creates an instance of Chrome and browses to the Amazon front page and gathers every link it can find:\\n\\n```python\\n# filename: profiler_test.py\\nfrom selenium import webdriver\\n\\nCHROME_DRIVER_PATH = 'chromedriver.exe'\\n\\n\\ndef main():  \\n    d = webdriver.Chrome()\\n\\n    d.get(\\\"https://www.amazon.com\\\")\\n    d.maximize_window()\\n    get_all_pages_links(d)\\n    d.quit()\\n\\n\\ndef get_all_pages_links(d):  \\n    hrefs = []\\n    links = d.find_elements_by_tag_name('a')\\n    for link in links:\\n        href = link.get_attribute('href')\\n        hrefs.append(href)\\n    return hrefs\\n\\n\\nif __name__ == '__main__':  \\n    main()\\n```\\n\\nThis is the page we are seeing by the way:\\n\\n![](/content/images/2017/06/amazon.jpg)\\n\\n####Line Profiling\\nNow the question is, how long did it take us to get the `href` for every `a` tag present on this page? If you're curious, there were 428 total links present on this page alone. That is a lot of searching for Selenium's `find_elements_by_tag_name()` to do. One way to determine how fast our code is running is by using something called a [line profiler](https://www.huyng.com/posts/python-performance-analysis). We add a `@profile` decorator to both `main()` and `get_all_pages_links()` before running our profiler. Via the command line, we run the test with the command `kernprof.exe -l -v profiler_test.py`. Testing this with a profiler, the results are:\\n\\n```bash\\nWrote profile results to profiler_test.py.lprof  \\nTimer unit: 4.26667e-07 s\\n\\nTotal time: 15.8145 s  \\nFile: profiler_test.py  \\nFunction: main at line 8\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n     8                                           @profile\\n     9                                           def main():\\n    10         1      8780838 8780838.0     23.7      d = webdriver.Chrome()\\n    11\\n    12         1      2672345 2672345.0      7.2      d.get(\\\"https://www.amazon.com\\\")\\n    13         1      2871840 2871840.0      7.7      d.maximize_window()\\n    14         1     15225302 15225302.0     41.1      get_all_pages_links(d)\\n    15         1      7514945 7514945.0     20.3      d.quit()\\n\\nTotal time: 6.49449 s  \\nFile: profiler_test.py  \\nFunction: get_all_pages_links at line 18\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n    18                                           @profile\\n    19                                           def get_all_pages_links(d):\\n    20         1            3      3.0      0.0      hrefs = []\\n    21         1      3620538 3620538.0     23.8      links = d.find_elements_by_tag_name('a')\\n    22       428         1198      2.8      0.0      for link in links:\\n    23       427     11595822  27156.5     76.2          href = link.get_attribute('href')\\n    24       427         3875      9.1      0.0          hrefs.append(href)\\n    25         1            1      1.0      0.0      return hrefs\\n```\\n\\nWe see that it took nearly 15.8 seconds for the Chrome instance to start, to navigate to the Amazon page, to gather all links, and then to quit. What was the longest part of this runtime? It was line 23, the one where we ask for each a tag's `href`. In fact, this gathering of `href` values account for 76% of our runtime within the `get_all_pages_links()` function (about 4.94 seconds or more than one-fourth of the total script runtime). This is far too long in terms of automatic web testing. Imagine you needed to gather all links from hundreds and thousands of web pages? The process would take hours for even simple websites.\\n\\n####Utilizing XPath\\nHow can we do better? What other functions can we call from our webdriver.Chrome class such that we can make finding tags and their attributes faster? What if we tried to find all the a tags and their hrefs using XPath? Let's try it. Our code now looks like:\\n\\n```python\\n# filename: profiler_test.py\\n\\nfrom selenium import webdriver\\n\\nCHROME_DRIVER_PATH = 'chromedriver.exe'\\n\\n\\n@profile\\ndef main():  \\n    d = webdriver.Chrome()\\n\\n    d.get(\\\"https://www.amazon.com\\\")\\n    d.maximize_window()\\n    get_all_pages_links(d)\\n    d.quit()\\n\\n\\n@profile\\ndef get_all_pages_links(d):  \\n    hrefs = []\\n    links = d.find_elements_by_xpath('//a')\\n    for link in links:\\n        href = link.get_attribute('href')\\n        hrefs.append(href)\\n    return hrefs\\n\\n\\nif __name__ == '__main__':  \\n    main()\\n```\\n\\nAnd the results from running with the profiler:\\n\\n```bash\\nWrote profile results to profiler_test.py.lprof  \\nTimer unit: 4.26667e-07 s\\n\\nTotal time: 16.262 s  \\nFile: profiler_test.py  \\nFunction: main at line 8\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n     8                                           @profile\\n     9                                           def main():\\n    10         1      8203882 8203882.0     21.5      d = webdriver.Chrome()\\n    11\\n    12         1      8535178 8535178.0     22.4      d.get(\\\"https://www.amazon.com\\\")\\n    13         1      2910691 2910691.0      7.6      d.maximize_window()\\n    14         1     10979849 10979849.0     28.8      get_all_pages_links(d)\\n    15         1      7484319 7484319.0     19.6      d.quit()\\n\\nTotal time: 4.68298 s  \\nFile: profiler_test.py  \\nFunction: get_all_pages_links at line 18\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n    18                                           @profile\\n    19                                           def get_all_pages_links(d):\\n    20         1            3      3.0      0.0      hrefs = []\\n    21         1       317767 317767.0      2.9      links = d.find_elements_by_xpath('//a')\\n    22       431         1092      2.5      0.0      for link in links:\\n    23       430     10652981  24774.4     97.1          href = link.get_attribute('href')\\n    24       430         3875      9.0      0.0          hrefs.append(href)\\n    25         1            2      2.0      0.0      return hrefs\\n```\\n\\nThe same gathering operation now takes around 4.5 seconds. This is an improvement of about half a second. Although good, this is not helpful in the bigger picture. We need these links, and we need them fast. So here's one last idea.\\n\\n####Scripts Within Scripts\\nSelenium WebDrivers have a function called `execute_script()`, which as the name implies injects (JavaScript) code into the browser and returns whatever result that the code does. How about we check to see if directly injecting such a code is faster at getting all the page's links when compared to using `get_attribute()`? The raw JavaScript code to retrieve all page `href` values is coded as such:\\n\\n```javascript\\nfunction get_all_hrefs() {  \\n    var anchors = document.links;\\n    var hrefs = [];\\n    for (var i=0; i<anchors .length; i++) {\\n        hrefs.push(anchors[i].href);\\n    }\\n\\n    return hrefs;\\n}\\n```\\n\\nWe re-write `profiler_test.py` to use this function:\\n\\n```python\\n# filename: profiler_test.py\\n\\nfrom selenium import webdriver\\n\\nCHROME_DRIVER_PATH = 'chromedriver.exe'\\n\\nJS_GET_ALL_HREFS = r'''function get_all_hrefs() {  \\n    var anchors = document.links;\\n    var hrefs = [];\\n    for (var i=0; i<anchors .length; i++) {\\n        hrefs.push(anchors[i].href);\\n    }\\n\\n    return hrefs;\\n}\\nreturn get_all_hrefs();  \\n'''\\n\\n@profile\\ndef main():  \\n    d = webdriver.Chrome()\\n\\n    d.get(\\\"https://www.amazon.com\\\")\\n    d.maximize_window()\\n    get_all_pages_links(d)\\n    d.quit()\\n\\n\\n@profile\\ndef get_all_pages_links(d):  \\n    hrefs = d.execute_script(JS_GET_ALL_HREFS)\\n    return hrefs\\n\\n\\nif __name__ == '__main__':  \\n    main()\\n```\\n\\nAnd lastly, we test with the line profiler:\\n\\n```bash\\nWrote profile results to profiler_test.py.lprof  \\nTimer unit: 4.26667e-07 s\\n\\nTotal time: 10.4917 s  \\nFile: profiler_test.py  \\nFunction: main at line 19\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n    19                                           @profile\\n    20                                           def main():\\n    21         1      8136920 8136920.0     33.1      d = webdriver.Chrome()\\n    22\\n    23         1      5377998 5377998.0     21.9      d.get(\\\"https://www.amazon.com\\\")\\n    24         1      2888695 2888695.0     11.7      d.maximize_window()\\n    25         1       203765 203765.0      0.8      H = get_all_pages_links(d)\\n    26       451         4658     10.3      0.0      for h in H:\\n    27       450       489150   1087.0      2.0          print(h)\\n    28         1      7488800 7488800.0     30.5      d.quit()\\n\\nTotal time: 0.0868468 s  \\nFile: profiler_test.py  \\nFunction: get_all_pages_links at line 31\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n    31                                           @profile\\n    32                                           def get_all_pages_links(d):\\n    33         1       203523 203523.0    100.0      hrefs = d.execute_script(JS_GET_ALL_HREFS)\\n    34         1           24     24.0      0.0      return hrefs\\n```\\n\\nThe results speak for themselves. The runtime of `get_all_pages_links()` went from 6.49 seconds to 4.68 seconds to **0.086 seconds**. We improved the time needed to scrape all the page's links by a **factor of more than 75**. These results demonstrate the power of line profiling and how it can be used to drastically improve runtimes. Testing each type of function in a case by case basis lets developers know exactly which ones will run most efficiently so that they can create faster and more robust automated tests. In this case, the links were able to scraped in an alternative way such that we had to go through one less layer of abstraction. Instead of using the Selenium library within Python to access browser elements, we use JavaScript to access those elements much more quickly, and then simply send the results back to our library for processing. By cutting out the middleman, we save time and computational power.\"}]],\"markups\":[],\"sections\":[[10,0]]}","created_at_ts":1549516031840,"created_at":"2019-02-07T05:07:11.000Z"},{"id":"5c5bbee75d0d6b08c5580002","post_id":"5c5bbbc35d0d6b08c557fff6","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"The problems below were posed by my *Design and Analysis of Algorithms* professor. Although we did not spend much time on the solution or its implications, I figured over-analyzing it might be in order if I wanted to read back on this in the future and think of the productivity wasted on this post.\\n\\n#### The initial problem\\nGiven a special candle of unknown length that burns up in one hour regardless of the orientation it is placed in (i.e. whether the candle is lit upside down or right side up or some other degree of rotation), how can you use this candle as a timer to know when 30 minutes have passed? The density of the candle's wax varies along the whole length, so two equal lengths will burn up in different times (you aren't allowed to measure the length of the candle anyway). Assume the wick is present on both ends of the candle (meaning you can light two fires at once), and that you are able to light a fire or split the candle with no loss of relative time. Remember: you need the timer to start immediately, so the goal is to use the candle as a timer, not to be left with a candle timer. This is a variation of the [burning rope problem](https://curiosity.com/topics/the-burning-rope-logic-puzzle/) but uses the more environmentally conscious alternative to setting ropes on fire: burning candles.\\n\\n#### The initial solution\\nLight both ends of the candle. It is trivial to see how we can measure 30 minutes using a single candle and two fires. Regardless of how long the candle is, we simply need the information that the whole candle will burn in one hour; this means that the amount of wax present is only able to fuel one hour of burn time with one fire going. Thus, burning two fires using both ends of the candle means using the same amount of fuel but twice as fast. Therefore, once the two fires meet and the candle runs out of wax, 30 minutes have passed.\\n\\n#### Blackouts are inconvenient\\nSay you found a stash of more one-hour candles. What if you had the same problem as above, but now wanted to measure 45 minutes? We already know how to achieve 30 minutes using one candle, so going for 45 minutes with two candles should not be a tall order. The solution is as follows: light the two ends of the first candle as above, but also light one end of a second candle. Once the first candle burns out in 30 minutes, we are left with 30 minutes remaining on the second burning candle. Light the unlit end in order to get this candle to use fuel twice as fast, so that it burns out in 15 minutes. This gives us 45 minutes of total light we wanted.\\n\\nWhat happens if we wanted to get 15 minutes using only one candle? Turns out, this is the hardest of the problems encountered so far. Since we only have one candle, it'd be impossible to get any amount of time less than 30 minutes without having to split the candle into two or more parts. Thus, the solution lies in breaking this one candle into two pieces of candle. The non-intuitive part of it all is that the length of the two pieces do not matter in this solution. In fact, length does not play a role in finding the solution to any amount of time, which is why the seemingly unknown length is irrelevant to the whole thing. We now have two (unequal) child parts of the same candle. The first step of the solution is to light both ends of both candles, so that there are 4 fires burning at the same time. You can sort of see a pattern now: one fire equals an hour of light, two fires give half that time, etc. The caveat to burning four fires is knowing what to do after the first of the two pairs of fires burn out earlier than the other (which it will, as the two unequal pieces imply that one has to be shorter). The solution is simple: the moment the first child candle burn out, take the other candle and split it into two child pieces again, and make sure both ends are lit for each. Since we are assuming there is no wasted time in splitting candles and lighting fires, the candles will all eventually burn out completely in 15 minutes. Simply explained, the whole candle will burn out in 15 minutes because you will always have four fires burning simultaneously. This is similar to the 30 minutes solution: at any time, your candle will be burning two fires, so it runs out of fuel twice as fast. In this solution, your candle is running out of fuel 4 times as fast, and therefore your fuel lasts a fourth of an hour. In general, if you had multiple children candles, you split a remaining candle every time one of them burns out in order to maintain the same number of fires alive to consume the total fuel.\\n\\nThe table below shows the general pattern of parts and fires needed to achieve a given burning time in minutes for one candle. Parts, in this case, means the number of parts you are splitting the initial candle into, and does not account for the times you recursively break up the child candles.\\n\\n<table>\\n  <tr>\\n    <th>Parts</th>\\n    <th>Fires</th> \\n    <th>Time</th>\\n  </tr>\\n  <tr>\\n    <td>1</td>\\n    <td>1</td> \\n    <td>60</td>\\n  </tr>\\n  <tr>\\n    <td>1</td>\\n    <td>2</td> \\n    <td>30</td>\\n  </tr>\\n  <tr>\\n    <td>2</td>\\n    <td>3</td> \\n    <td>20</td>\\n  </tr>\\n  <tr>\\n    <td>2</td>\\n    <td>4</td> \\n    <td>15</td>\\n  </tr>\\n  <tr>\\n    <td>3</td>\\n    <td>5</td> \\n    <td>12</td>\\n  </tr>\\n  <tr>\\n    <td>3</td>\\n    <td>6</td> \\n    <td>10</td>\\n  </tr>\\n</table>\\n\\n#### What time is it?\\nThe general equation for the number of fires $f$ needed to achieve a time $t$ in minutes is then simply $f=\\\\frac{60}t$. The number of parts $p$ needed given $f$ is then $p=\\\\lceil\\\\frac{f}2 \\\\rceil$. Keep in mind that this equation is valid only if we have one candle, and therefore $f\\\\in\\\\mathbb{Z^+}$. If such is the case, then the only exact times we are able to achieve with one candle are the quotients of dividing 60 by any positive integer. We can say that given a candle that normally burns (with a single flame) in $m$ minutes, the set of all solutions are in $\\\\\\\\{\\\\frac mz \\\\mid z\\\\in\\\\mathbb{Z^+}\\\\\\\\}$. So, knowing how the solution plays out, and how long one candle burns for, let's write a simple Python script to calculate how many parts the initial candle needs to be split into, and how many fires need to be simultaneously lit in order to achieve a desired time. We have two arguments to pass in: `burn_rate` (the time it takes to burn the whole candle with a single fire) and `target_time` (a time you'd like to waste playing with candles). The program should output a tuple: the former number will be the parts to split into and the latter will be the number of fires to light between all those parts. These two pieces of information will get you as close to your `target_time` as possible without exceeding it. The code below demonstrates one way of achieving this.\\n\\n```language-python\\nimport math\\n\\ndef candle_waster(burn_rate, target_time):\\n  fires = math.ceil(burn_rate/target_time)\\n  parts = math.ceil(fires/2)\\n  if target_time > burn_rate:\\n    return \\\"Can't burn candle longer than burn_rate\\\"\\n  return parts, fires\\n    \\nprint(candle_waster(60,15))\\nprint(candle_waster(30,5))\\nprint(candle_waster(10,1))\\nprint(candle_waster(5,3))\\nprint(candle_waster(1,2))\\n```\\n```language-none\\n(2, 4)\\n(3, 6)\\n(5, 10)\\n(1, 2)\\nCan't burn candle longer than burn_rate\\n```\\nThat was the easier part. Let's figure out what times we're able to achieve with more than one candle.\\n\\n#### Lots and lots of wax\\n\\nSuppose now we have two candles that all have the same burn rate of $m$ minutes each. It is simple to see that we are able to achieve a maximum time of $2m$ minutes by using them in succession&mdash;that is, burning them one by one until we're done. In fact, these \\\"additive\\\" times are reached simply by adding any times $t\\\\_1$ and $t\\\\_2$ together such that $t\\\\_1, t\\\\_2 \\\\in S$, where $S = \\\\\\\\{\\\\frac mz \\\\mid z\\\\in\\\\mathbb{Z^+}\\\\\\\\}$ (the set of times possible with each candle of burn rate $m$). One can see that $\\\\lvert S \\\\rvert = \\\\infty$ because we haven't defined proper constraints for $z$. For our sake, we can define a maximum number of fires $e$ allowed for each candle (meaning no one candle can have more than $e$ fires ablaze at one time, which limits the magnitude of $S$ to a finite number). Furthermore, let's define $S\\\\_{m,e}$ to mean **the set of times achievable with a single candle of burn rate $m$ and max fires of $e$**:\\n$$\\nS\\\\_{m,e} = \\\\\\\\{\\\\frac mz \\\\mid z\\\\in\\\\mathbb{Z^+}, 1 \\\\leq z \\\\leq e \\\\\\\\}\\n$$\\nAs an example, set $m=60, e=3$. Thus, the two candles are able to produce the times in $S\\\\_{60,3}$ *individually*. This means that, by itself, any one of the two candles can produce any of these times in the set $S\\\\_{60,3} = \\\\\\\\{60,30,20\\\\\\\\}$. Utilizing both of them, however, produces a wider range of possible times.\\n\\n---\\n\\nThe set of possible times of using *both* candles is expanded because you have more choices as to how you go about lighting, splitting, and delaying each candle. One set of possibilities is the option of successively lighting each candle after the last one burns out. Let's call this set of times $T\\\\_{sc}$. In our example above, each candle is able to burn for either 60, 30, or 20 minutes each. We see that if we burn the first candle for 60 minutes, *then* burn the second for 60 minutes, we've produced a new possible time of 120 minutes. Each of the times in $S\\\\_{60,3}$ is added to all possible times also in the same set $S\\\\_{60,3}$. As such, we are left with $T\\\\_{sc}$ containing the set of numbers which result from the [Minkowski addition](https://en.wikipedia.org/wiki/Minkowski_addition) (or direct sum) of $S\\\\_{60,3}$ and itself. It's intuitive to see how the times form from successive burning, and we demonstrate it below with all possible cases of said process. Let the first and second candles, along with their remaining burn times, be $c\\\\_{1},c\\\\_{2},b\\\\_{1},b\\\\_{2}$, respectively.\\n\\nSuccessive burning:\\n\\n* (Case 1) $c\\\\_{1}$ burns for $b\\\\_{1}=60$ minutes, then\\n    * (1A) $c\\\\_{2}$ burns for $b\\\\_{2}=60$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 120 minutes.\\n    * (1B) $c\\\\_{2}$ burns for $b\\\\_{2}=30$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 90 minutes.\\n    * (1C) $c\\\\_{2}$ burns for $b\\\\_{2}=20$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 80 minutes.\\n\\n* (Case 2) $c\\\\_{1}$ burns for $b\\\\_{1}=30$ minutes, then\\n    * (2A) $c\\\\_{2}$ burns for $b\\\\_{2}=60$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 90 minutes.\\n    * (2B) $c\\\\_{2}$ burns for $b\\\\_{2}=30$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 60 minutes.\\n    * (2C) $c\\\\_{2}$ burns for $b\\\\_{2}=20$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 50 minutes.\\n\\n* (Case 3) $c\\\\_{1}$ burns for $b\\\\_{1}=20$ minutes, then\\n    * (3A) $c\\\\_{2}$ burns for $b\\\\_{2}=60$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 80 minutes.\\n    * (3B) $c\\\\_{2}$ burns for $b\\\\_{2}=30$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 50 minutes.\\n    * (3C) $c\\\\_{2}$ burns for $b\\\\_{2}=20$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 40 minutes.\\n\\nThus, $T\\\\_{sc} = \\\\\\\\{120,90,80,60,50,40\\\\\\\\}$ given two candles, with $m=60, e=3$. The other option of discovering time possibilities is the idea of simultaneously burning the candles. This method is a bit trickier. Recall that towards the start of this post was a solution for 45 minutes that involved two candles: the first candle was lit on one end and the second was lit on both ends. Both burned for 30 minutes (until the second one burned out) and the first one was left with 30 remaining minutes of wax (30 minutes have also passed at this point). We ensured the remaining one had two fires ablaze and thus burned twice as fast with 30 minutes of fuel left, which means it burned for 15 minutes. The 30 minutes from the simultaneous burning and the 15 from the remainder burning produced 45 total minutes. This was possible because we were able to reduce the first candle's burn rate down by any attainable time of the second candle, and from there we solved the sub-problem of getting 15 minutes using an $m=30$ candle. Let $T\\\\_{sim}$ be the set of times that result from simultaneously burning both candles and adding on the time possibility set of the remaining candle. Each case of these simultaneously burnings are outline below.\\n\\nSimultaneous (then remainder) burning:\\n\\n* (Case 1) Light $c\\\\_{1}$ with 1 fire ($b\\\\_{1}=60$) along with\\n    * (1A) $c\\\\_{2}$ with 1 fire ($b\\\\_{2}=60$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=0$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 60+\\\\\\\\{0\\\\\\\\} = \\\\\\\\{60\\\\\\\\}$\\n    * (1B) $c\\\\_{2}$ with 2 fires ($b\\\\_{2}=30$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=30$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 30+\\\\\\\\{30,15,10\\\\\\\\} = \\\\\\\\{60,45,40\\\\\\\\}$\\n    * (1C) $c\\\\_{2}$ with 3 fires ($b\\\\_{2}=20$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=40$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 20+\\\\\\\\{40,20,\\\\frac{40}3\\\\\\\\} = \\\\\\\\{60,40,33\\\\frac13\\\\\\\\}$\\n\\n* (Case 2) Light $c\\\\_{1}$ with 2 fires ($b\\\\_{1}=30$) along with\\n    * (2A) $c\\\\_{2}$ with 1 fire ($b\\\\_{2}=60$) $\\\\rightarrow$ same as case 1B.\\n    * (2B) $c\\\\_{2}$ with 2 fires ($b\\\\_{2}=30$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=0$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 30+\\\\\\\\{0\\\\\\\\} = \\\\\\\\{30\\\\\\\\}$\\n    * (2C) $c\\\\_{2}$ with 3 fires ($b\\\\_{2}=20$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=10$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 20+\\\\\\\\{10,5,\\\\frac{10}3\\\\\\\\} = \\\\\\\\{30,25,23\\\\frac13\\\\\\\\}$\\n\\n* (Case 3) Light $c\\\\_{1}$ with 3 fires ($b\\\\_{1}=20$) along with\\n    * (3A) $c\\\\_{2}$ with 1 fire ($b\\\\_{2}=60$) $\\\\rightarrow$ same as case 1C.\\n    * (3B) $c\\\\_{2}$ with 2 fires ($b\\\\_{2}=30$) $\\\\rightarrow$ same as case 2C.\\n    * (3C) $c\\\\_{2}$ with 3 fires ($b\\\\_{2}=20$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=0$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 20+\\\\\\\\{0\\\\\\\\} = \\\\\\\\{20\\\\\\\\}$\\n\\nThus, $T\\\\_{sim} = \\\\\\\\{60,45,40,33\\\\frac13,30,25,23\\\\frac13,20\\\\\\\\}$ given two candles, with $m=60, e=3$. We have then that given these two candles, we're about to produce the final set of times $T$:\\n$$\\nT = S\\\\_{60,3} \\\\cup T\\\\_{sc} \\\\cup T\\\\_{sim}=\\\\\\\\{120,90,80,60,50,45,40,33\\\\frac13,30,25,23\\\\frac13,20\\\\\\\\}\\n$$\\nNow, what would happen with three candles? The short story is, the successive times of three candles with the same burn rate and max fires is simply the direct sum of our previous times of 2 candles $T$ with another $S\\\\_{60,3}$. Similarly, the possible simultaneous times of this group would utilize the same procedure we used for $S\\\\_{60,3}$, except now we find all possible cases using the expanded set of times $T$ instead. Let's define a few functions back in Python to help us figure out all the times given a number of `candles`, a `burn_rate`, and `max_fires`. The function `times_succession()` accepts two sets and returns the direct sum of those two sets. The function `times_simul()` accepts two sets and max fires, and returns the set of times as described in our simultaneous and remainder burning above. `times_of_one_candle()` simply returns the set of times possible with one candle given its burn rate and max fires.\\n\\n```language-python\\ndef times_succession(set_one, set_two):\\n    t_sc = set([])\\n\\n    for x in set_one:\\n        for y in set_two:\\n            t_sc |= {round(x + y, 4)}\\n\\n    return t_sc\\n\\n\\ndef times_simul(set_one, set_two, max_fires):\\n    t_sim = set([])\\n\\n    for x in set_one:\\n        for y in set_two:\\n            if x >= y:\\n                remaining_time = x - y\\n                t = times_succession({round(y, 4)}, times_of_one_candle(remaining_time, max_fires))\\n                t_sim |= t\\n\\n    return t_sim\\n\\n\\ndef times_of_one_candle(burn_rate, max_fires):\\n    s = set([])\\n\\n    for x in range(1, max_fires + 1):\\n        s |= {burn_rate / x}\\n\\n    return s\\n```\\n\\nWe now have functions that return all the subsets needed for our equation in order to find all the possible sets given the correct parameters. Let's write a function `all_times()`, which takes in our three arguments `candles`, `burn_rate`, and `max_fires` and calls our helper functions to return the set of all times that we are able to achieve with these constraints.\\n\\n```language-python\\ndef all_times(candles, burn_rate, max_fires):\\n    if candles == 0 or burn_rate == 0 or max_fires == 0:\\n        return set([])\\n    if candles == 1:\\n        return times_of_one_candle(burn_rate, max_fires)\\n\\n    times = set([])\\n\\n    s = times_of_one_candle(burn_rate, max_fires)\\n    times |= s\\n\\n    for c in range(1, candles):\\n        t_sc = times_succession(times, s)\\n        t_sim = times_simul(times, s, max_fires)\\n        times |= (t_sc | t_sim)\\n\\n    return times\\n\\ns = sorted(all_times(2, 60, 3), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n    \\ns = sorted(all_times(3, 60, 4), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n    \\ns = sorted(all_times(4, 100, 5), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n    \\ns = sorted(all_times(5, 100, 6), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n    \\ns = sorted(all_times(6, 200, 5), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n```\\n```language-none\\n[120.0, 90.0, 80.0, 60.0, 50.0, 45.0, 40.0, 33.3333, 30.0, 25.0, 23.3333, 20.0]\\nMagnitude: 12\\n[180.0, 150.0, 140.0, 120.0, 110.0, 105.0, 100.0, 93.3333, 90.0, 85.0, 83.3333, ...]\\nMagnitude: 100\\n[400.0, 350.0, 333.3333, 325.0, 300.0, 283.3333, 275.0, 266.6667, 266.6666, ...]\\nMagnitude: 2414\\n[500.0, 450.0, 433.3333, 425.0, 420.0, 400.0, 383.3333, 375.0, 370.0, 366.6667, ...]\\nMagnitude: 30885\\n[1200.0, 1100.0, 1066.6667, 1050.0, 1040.0, 1000.0, 966.6667, 950.0, 940.0, ...]\\nMagnitude: 75430\\n```\\n\\nThe magnitude of each set displayed is simply the number of possible times. At this point, it's trivial to search for a time goal by reversing the process such that the script gives us `candles`, `burn_rate`, and/or `max_fires` given an input time goal.\\n\\nFinally, it is also pretty trivial to imagine how many hours and chances ago I should have stopped trying to dive into this problem, but we both know those attempts were futile.\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]]}","created_at_ts":1549516519972,"created_at":"2019-02-07T05:15:19.000Z"},{"id":"5c5bbf2f5d0d6b08c5580003","post_id":"5c5bbbc35d0d6b08c557fff6","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"The problems below were posed by my *Design and Analysis of Algorithms* professor. Although we did not spend much time on the solution or its implications, I figured over-analyzing it might be in order if I wanted to read back on this in the future and think of the productivity wasted on this post.\\n\\n#### The initial problem\\nGiven a special candle of unknown length that burns up in one hour regardless of the orientation it is placed in (i.e. whether the candle is lit upside down or right side up or some other degree of rotation), how can you use this candle as a timer to know when 30 minutes have passed? The density of the candle's wax varies along the whole length, so two equal lengths will burn up in different times (you aren't allowed to measure the length of the candle anyway). Assume the wick is present on both ends of the candle (meaning you can light two fires at once), and that you are able to light a fire or split the candle with no loss of relative time. Remember: you need the timer to start immediately, so the goal is to use the candle as a timer, not to be left with a candle timer. This is a variation of the [burning rope problem](https://curiosity.com/topics/the-burning-rope-logic-puzzle/) but uses the more environmentally conscious alternative to setting ropes on fire: burning candles.\\n\\n#### The initial solution\\nLight both ends of the candle. It is trivial to see how we can measure 30 minutes using a single candle and two fires. Regardless of how long the candle is, we simply need the information that the whole candle will burn in one hour; this means that the amount of wax present is only able to fuel one hour of burn time with one fire going. Thus, burning two fires using both ends of the candle means using the same amount of fuel but twice as fast. Therefore, once the two fires meet and the candle runs out of wax, 30 minutes have passed.\\n\\n#### Blackouts are inconvenient\\nSay you found a stash of more one-hour candles. What if you had the same problem as above, but now wanted to measure 45 minutes? We already know how to achieve 30 minutes using one candle, so going for 45 minutes with two candles should not be a tall order. The solution is as follows: light the two ends of the first candle as above, but also light one end of a second candle. Once the first candle burns out in 30 minutes, we are left with 30 minutes remaining on the second burning candle. Light the unlit end in order to get this candle to use fuel twice as fast, so that it burns out in 15 minutes. This gives us 45 minutes of total light we wanted.\\n\\nWhat happens if we wanted to get 15 minutes using only one candle? Turns out, this is the hardest of the problems encountered so far. Since we only have one candle, it'd be impossible to get any amount of time less than 30 minutes without having to split the candle into two or more parts. Thus, the solution lies in breaking this one candle into two pieces of candle. The non-intuitive part of it all is that the length of the two pieces do not matter in this solution. In fact, length does not play a role in finding the solution to any amount of time, which is why the seemingly unknown length is irrelevant to the whole thing. We now have two (unequal) child parts of the same candle. The first step of the solution is to light both ends of both candles, so that there are 4 fires burning at the same time. You can sort of see a pattern now: one fire equals an hour of light, two fires give half that time, etc. The caveat to burning four fires is knowing what to do after the first of the two pairs of fires burn out earlier than the other (which it will, as the two unequal pieces imply that one has to be shorter). The solution is simple: the moment the first child candle burns out, take the other candle and split it into two child pieces again, and make sure both ends are lit for each. Since we are assuming there is no wasted time in splitting candles and lighting fires, the candles will all eventually burn out completely in 15 minutes. Simply explained, the whole candle will burn out in 15 minutes because you will always have four fires burning simultaneously. This is similar to the 30 minutes solution: at any time, your candle will be burning two fires, so it runs out of fuel twice as fast. In this solution, your candle is running out of fuel 4 times as fast, and therefore your fuel lasts a fourth of an hour. In general, if you had multiple children candles, you split a remaining candle every time one of them burns out in order to maintain the same number of fires alive to consume the total fuel.\\n\\nThe table below shows the general pattern of parts and fires needed to achieve a given burning time in minutes for one candle. Parts, in this case, means the number of parts you are splitting the initial candle into, and does not account for the times you recursively break up the child candles.\\n\\n<table>\\n  <tr>\\n    <th>Parts</th>\\n    <th>Fires</th> \\n    <th>Time</th>\\n  </tr>\\n  <tr>\\n    <td>1</td>\\n    <td>1</td> \\n    <td>60</td>\\n  </tr>\\n  <tr>\\n    <td>1</td>\\n    <td>2</td> \\n    <td>30</td>\\n  </tr>\\n  <tr>\\n    <td>2</td>\\n    <td>3</td> \\n    <td>20</td>\\n  </tr>\\n  <tr>\\n    <td>2</td>\\n    <td>4</td> \\n    <td>15</td>\\n  </tr>\\n  <tr>\\n    <td>3</td>\\n    <td>5</td> \\n    <td>12</td>\\n  </tr>\\n  <tr>\\n    <td>3</td>\\n    <td>6</td> \\n    <td>10</td>\\n  </tr>\\n</table>\\n\\n#### What time is it?\\nThe general equation for the number of fires $f$ needed to achieve a time $t$ in minutes is then simply $f=\\\\frac{60}t$. The number of parts $p$ needed given $f$ is then $p=\\\\lceil\\\\frac{f}2 \\\\rceil$. Keep in mind that this equation is valid only if we have one candle, and therefore $f\\\\in\\\\mathbb{Z^+}$. If such is the case, then the only exact times we are able to achieve with one candle are the quotients of dividing 60 by any positive integer. We can say that given a candle that normally burns (with a single flame) in $m$ minutes, the set of all solutions are in $\\\\\\\\{\\\\frac mz \\\\mid z\\\\in\\\\mathbb{Z^+}\\\\\\\\}$. So, knowing how the solution plays out, and how long one candle burns for, let's write a simple Python script to calculate how many parts the initial candle needs to be split into, and how many fires need to be simultaneously lit in order to achieve a desired time. We have two arguments to pass in: `burn_rate` (the time it takes to burn the whole candle with a single fire) and `target_time` (a time you'd like to waste playing with candles). The program should output a tuple: the former number will be the parts to split into and the latter will be the number of fires to light between all those parts. These two pieces of information will get you as close to your `target_time` as possible without exceeding it. The code below demonstrates one way of achieving this.\\n\\n```language-python\\nimport math\\n\\ndef candle_waster(burn_rate, target_time):\\n  fires = math.ceil(burn_rate/target_time)\\n  parts = math.ceil(fires/2)\\n  if target_time > burn_rate:\\n    return \\\"Can't burn candle longer than burn_rate\\\"\\n  return parts, fires\\n    \\nprint(candle_waster(60,15))\\nprint(candle_waster(30,5))\\nprint(candle_waster(10,1))\\nprint(candle_waster(5,3))\\nprint(candle_waster(1,2))\\n```\\n```language-none\\n(2, 4)\\n(3, 6)\\n(5, 10)\\n(1, 2)\\nCan't burn candle longer than burn_rate\\n```\\nThat was the easier part. Let's figure out what times we're able to achieve with more than one candle.\\n\\n#### Lots and lots of wax\\n\\nSuppose now we have two candles that all have the same burn rate of $m$ minutes each. It is simple to see that we are able to achieve a maximum time of $2m$ minutes by using them in succession&mdash;that is, burning them one by one until we're done. In fact, these \\\"additive\\\" times are reached simply by adding any times $t\\\\_1$ and $t\\\\_2$ together such that $t\\\\_1, t\\\\_2 \\\\in S$, where $S = \\\\\\\\{\\\\frac mz \\\\mid z\\\\in\\\\mathbb{Z^+}\\\\\\\\}$ (the set of times possible with each candle of burn rate $m$). One can see that $\\\\lvert S \\\\rvert = \\\\infty$ because we haven't defined proper constraints for $z$. For our sake, we can define a maximum number of fires $e$ allowed for each candle (meaning no one candle can have more than $e$ fires ablaze at one time, which limits the magnitude of $S$ to a finite number). Furthermore, let's define $S\\\\_{m,e}$ to mean **the set of times achievable with a single candle of burn rate $m$ and max fires of $e$**:\\n$$\\nS\\\\_{m,e} = \\\\\\\\{\\\\frac mz \\\\mid z\\\\in\\\\mathbb{Z^+}, 1 \\\\leq z \\\\leq e \\\\\\\\}\\n$$\\nAs an example, set $m=60, e=3$. Thus, the two candles are able to produce the times in $S\\\\_{60,3}$ *individually*. This means that, by itself, any one of the two candles can produce any of these times in the set $S\\\\_{60,3} = \\\\\\\\{60,30,20\\\\\\\\}$. Utilizing both of them, however, produces a wider range of possible times.\\n\\n---\\n\\nThe set of possible times of using *both* candles is expanded because you have more choices as to how you go about lighting, splitting, and delaying each candle. One set of possibilities is the option of successively lighting each candle after the last one burns out. Let's call this set of times $T\\\\_{sc}$. In our example above, each candle is able to burn for either 60, 30, or 20 minutes each. We see that if we burn the first candle for 60 minutes, *then* burn the second for 60 minutes, we've produced a new possible time of 120 minutes. Each of the times in $S\\\\_{60,3}$ is added to all possible times also in the same set $S\\\\_{60,3}$. As such, we are left with $T\\\\_{sc}$ containing the set of numbers which result from the [Minkowski addition](https://en.wikipedia.org/wiki/Minkowski_addition) (or direct sum) of $S\\\\_{60,3}$ and itself. It's intuitive to see how the times form from successive burning, and we demonstrate it below with all possible cases of said process. Let the first and second candles, along with their remaining burn times, be $c\\\\_{1},c\\\\_{2},b\\\\_{1},b\\\\_{2}$, respectively.\\n\\nSuccessive burning:\\n\\n* (Case 1) $c\\\\_{1}$ burns for $b\\\\_{1}=60$ minutes, then\\n    * (1A) $c\\\\_{2}$ burns for $b\\\\_{2}=60$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 120 minutes.\\n    * (1B) $c\\\\_{2}$ burns for $b\\\\_{2}=30$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 90 minutes.\\n    * (1C) $c\\\\_{2}$ burns for $b\\\\_{2}=20$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 80 minutes.\\n\\n* (Case 2) $c\\\\_{1}$ burns for $b\\\\_{1}=30$ minutes, then\\n    * (2A) $c\\\\_{2}$ burns for $b\\\\_{2}=60$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 90 minutes.\\n    * (2B) $c\\\\_{2}$ burns for $b\\\\_{2}=30$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 60 minutes.\\n    * (2C) $c\\\\_{2}$ burns for $b\\\\_{2}=20$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 50 minutes.\\n\\n* (Case 3) $c\\\\_{1}$ burns for $b\\\\_{1}=20$ minutes, then\\n    * (3A) $c\\\\_{2}$ burns for $b\\\\_{2}=60$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 80 minutes.\\n    * (3B) $c\\\\_{2}$ burns for $b\\\\_{2}=30$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 50 minutes.\\n    * (3C) $c\\\\_{2}$ burns for $b\\\\_{2}=20$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 40 minutes.\\n\\nThus, $T\\\\_{sc} = \\\\\\\\{120,90,80,60,50,40\\\\\\\\}$ given two candles, with $m=60, e=3$. The other option of discovering time possibilities is the idea of simultaneously burning the candles. This method is a bit trickier. Recall that towards the start of this post was a solution for 45 minutes that involved two candles: the first candle was lit on one end and the second was lit on both ends. Both burned for 30 minutes (until the second one burned out) and the first one was left with 30 remaining minutes of wax (30 minutes have also passed at this point). We ensured the remaining one had two fires ablaze and thus burned twice as fast with 30 minutes of fuel left, which means it burned for 15 minutes. The 30 minutes from the simultaneous burning and the 15 from the remainder burning produced 45 total minutes. This was possible because we were able to reduce the first candle's burn rate down by any attainable time of the second candle, and from there we solved the sub-problem of getting 15 minutes using an $m=30$ candle. Let $T\\\\_{sim}$ be the set of times that result from simultaneously burning both candles and adding on the time possibility set of the remaining candle. Each case of these simultaneously burnings are outline below.\\n\\nSimultaneous (then remainder) burning:\\n\\n* (Case 1) Light $c\\\\_{1}$ with 1 fire ($b\\\\_{1}=60$) along with\\n    * (1A) $c\\\\_{2}$ with 1 fire ($b\\\\_{2}=60$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=0$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 60+\\\\\\\\{0\\\\\\\\} = \\\\\\\\{60\\\\\\\\}$\\n    * (1B) $c\\\\_{2}$ with 2 fires ($b\\\\_{2}=30$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=30$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 30+\\\\\\\\{30,15,10\\\\\\\\} = \\\\\\\\{60,45,40\\\\\\\\}$\\n    * (1C) $c\\\\_{2}$ with 3 fires ($b\\\\_{2}=20$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=40$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 20+\\\\\\\\{40,20,\\\\frac{40}3\\\\\\\\} = \\\\\\\\{60,40,33\\\\frac13\\\\\\\\}$\\n\\n* (Case 2) Light $c\\\\_{1}$ with 2 fires ($b\\\\_{1}=30$) along with\\n    * (2A) $c\\\\_{2}$ with 1 fire ($b\\\\_{2}=60$) $\\\\rightarrow$ same as case 1B.\\n    * (2B) $c\\\\_{2}$ with 2 fires ($b\\\\_{2}=30$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=0$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 30+\\\\\\\\{0\\\\\\\\} = \\\\\\\\{30\\\\\\\\}$\\n    * (2C) $c\\\\_{2}$ with 3 fires ($b\\\\_{2}=20$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=10$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 20+\\\\\\\\{10,5,\\\\frac{10}3\\\\\\\\} = \\\\\\\\{30,25,23\\\\frac13\\\\\\\\}$\\n\\n* (Case 3) Light $c\\\\_{1}$ with 3 fires ($b\\\\_{1}=20$) along with\\n    * (3A) $c\\\\_{2}$ with 1 fire ($b\\\\_{2}=60$) $\\\\rightarrow$ same as case 1C.\\n    * (3B) $c\\\\_{2}$ with 2 fires ($b\\\\_{2}=30$) $\\\\rightarrow$ same as case 2C.\\n    * (3C) $c\\\\_{2}$ with 3 fires ($b\\\\_{2}=20$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=0$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 20+\\\\\\\\{0\\\\\\\\} = \\\\\\\\{20\\\\\\\\}$\\n\\nThus, $T\\\\_{sim} = \\\\\\\\{60,45,40,33\\\\frac13,30,25,23\\\\frac13,20\\\\\\\\}$ given two candles, with $m=60, e=3$. We have then that given these two candles, we're about to produce the final set of times $T$:\\n$$\\nT = S\\\\_{60,3} \\\\cup T\\\\_{sc} \\\\cup T\\\\_{sim}=\\\\\\\\{120,90,80,60,50,45,40,33\\\\frac13,30,25,23\\\\frac13,20\\\\\\\\}\\n$$\\nNow, what would happen with three candles? The short story is, the successive times of three candles with the same burn rate and max fires is simply the direct sum of our previous times of 2 candles $T$ with another $S\\\\_{60,3}$. Similarly, the possible simultaneous times of this group would utilize the same procedure we used for $S\\\\_{60,3}$, except now we find all possible cases using the expanded set of times $T$ instead. Let's define a few functions back in Python to help us figure out all the times given a number of `candles`, a `burn_rate`, and `max_fires`. The function `times_succession()` accepts two sets and returns the direct sum of those two sets. The function `times_simul()` accepts two sets and max fires, and returns the set of times as described in our simultaneous and remainder burning above. `times_of_one_candle()` simply returns the set of times possible with one candle given its burn rate and max fires.\\n\\n```language-python\\ndef times_succession(set_one, set_two):\\n    t_sc = set([])\\n\\n    for x in set_one:\\n        for y in set_two:\\n            t_sc |= {round(x + y, 4)}\\n\\n    return t_sc\\n\\n\\ndef times_simul(set_one, set_two, max_fires):\\n    t_sim = set([])\\n\\n    for x in set_one:\\n        for y in set_two:\\n            if x >= y:\\n                remaining_time = x - y\\n                t = times_succession({round(y, 4)}, times_of_one_candle(remaining_time, max_fires))\\n                t_sim |= t\\n\\n    return t_sim\\n\\n\\ndef times_of_one_candle(burn_rate, max_fires):\\n    s = set([])\\n\\n    for x in range(1, max_fires + 1):\\n        s |= {burn_rate / x}\\n\\n    return s\\n```\\n\\nWe now have functions that return all the subsets needed for our equation in order to find all the possible sets given the correct parameters. Let's write a function `all_times()`, which takes in our three arguments `candles`, `burn_rate`, and `max_fires` and calls our helper functions to return the set of all times that we are able to achieve with these constraints.\\n\\n```language-python\\ndef all_times(candles, burn_rate, max_fires):\\n    if candles == 0 or burn_rate == 0 or max_fires == 0:\\n        return set([])\\n    if candles == 1:\\n        return times_of_one_candle(burn_rate, max_fires)\\n\\n    times = set([])\\n\\n    s = times_of_one_candle(burn_rate, max_fires)\\n    times |= s\\n\\n    for c in range(1, candles):\\n        t_sc = times_succession(times, s)\\n        t_sim = times_simul(times, s, max_fires)\\n        times |= (t_sc | t_sim)\\n\\n    return times\\n\\ns = sorted(all_times(2, 60, 3), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n    \\ns = sorted(all_times(3, 60, 4), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n    \\ns = sorted(all_times(4, 100, 5), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n    \\ns = sorted(all_times(5, 100, 6), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n    \\ns = sorted(all_times(6, 200, 5), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n```\\n```language-none\\n[120.0, 90.0, 80.0, 60.0, 50.0, 45.0, 40.0, 33.3333, 30.0, 25.0, 23.3333, 20.0]\\nMagnitude: 12\\n[180.0, 150.0, 140.0, 120.0, 110.0, 105.0, 100.0, 93.3333, 90.0, 85.0, 83.3333, ...]\\nMagnitude: 100\\n[400.0, 350.0, 333.3333, 325.0, 300.0, 283.3333, 275.0, 266.6667, 266.6666, ...]\\nMagnitude: 2414\\n[500.0, 450.0, 433.3333, 425.0, 420.0, 400.0, 383.3333, 375.0, 370.0, 366.6667, ...]\\nMagnitude: 30885\\n[1200.0, 1100.0, 1066.6667, 1050.0, 1040.0, 1000.0, 966.6667, 950.0, 940.0, ...]\\nMagnitude: 75430\\n```\\n\\nThe magnitude of each set displayed is simply the number of possible times. At this point, it's trivial to search for a time goal by reversing the process such that the script gives us `candles`, `burn_rate`, and/or `max_fires` given an input time goal.\\n\\nFinally, it is also pretty trivial to imagine how many hours and chances ago I should have stopped trying to dive into this problem, but we both know those attempts were futile.first child candle burn o\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]]}","created_at_ts":1549516591227,"created_at":"2019-02-07T05:16:31.000Z"},{"id":"5c692fa85d0d6b08c5580005","post_id":"5c5bbbc35d0d6b08c557fff6","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"The problems below were posed by my *Design and Analysis of Algorithms* professor. Although we did not spend much time on the solution or its implications, I figured over-analyzing it might be in order if I wanted to read back on this in the future and think of the productivity wasted on this post.\\n\\n#### The initial problem\\nGiven a special candle of unknown length that burns up in one hour regardless of the orientation it is placed in (i.e. whether the candle is lit upside down or right side up or some other degree of rotation), how can you use this candle as a timer to know when 30 minutes have passed? The density of the candle's wax varies along the whole length, so two equal lengths will burn up in different times (you aren't allowed to measure the length of the candle anyway). Assume the wick is present on both ends of the candle (meaning you can light two fires at once), and that you are able to light a fire or split the candle with no loss of relative time. Remember: you need the timer to start immediately, so the goal is to use the candle as a timer, not to be left with a candle timer. This is a variation of the [burning rope problem](https://curiosity.com/topics/the-burning-rope-logic-puzzle/) but uses the more environmentally conscious alternative to setting ropes on fire: burning candles.\\n\\n#### The initial solution\\nLight both ends of the candle. It is trivial to see how we can measure 30 minutes using a single candle and two fires. Regardless of how long the candle is, we simply need the information that the whole candle will burn in one hour; this means that the amount of wax present is only able to fuel one hour of burn time with one fire going. Thus, burning two fires using both ends of the candle means using the same amount of fuel but twice as fast. Therefore, once the two fires meet and the candle runs out of wax, 30 minutes have passed.\\n\\n#### Blackouts are inconvenient\\nSay you found a stash of more one-hour candles. What if you had the same problem as above, but now wanted to measure 45 minutes? We already know how to achieve 30 minutes using one candle, so going for 45 minutes with two candles should not be a tall order. The solution is as follows: light the two ends of the first candle as above, but also light one end of a second candle. Once the first candle burns out in 30 minutes, we are left with 30 minutes remaining on the second burning candle. Light the unlit end in order to get this candle to use fuel twice as fast, so that it burns out in 15 minutes. This gives us 45 minutes of total light we wanted.\\n\\nWhat happens if we wanted to get 15 minutes using only one candle? Turns out, this is the hardest of the problems encountered so far. Since we only have one candle, it'd be impossible to get any amount of time less than 30 minutes without having to split the candle into two or more parts. Thus, the solution lies in breaking this one candle into two pieces of candle. The non-intuitive part of it all is that the length of the two pieces do not matter in this solution. In fact, length does not play a role in finding the solution to any amount of time, which is why the seemingly unknown length is irrelevant to the whole thing. We now have two (unequal) child parts of the same candle. The first step of the solution is to light both ends of both candles, so that there are 4 fires burning at the same time. You can sort of see a pattern now: one fire equals an hour of light, two fires give half that time, etc. The caveat to burning four fires is knowing what to do after the first of the two pairs of fires burn out earlier than the other (which it will, as the two unequal pieces imply that one has to be shorter). The solution is simple: the moment the first child candle burns out, take the other candle and split it into two child pieces again, and make sure both ends are lit for each. Since we are assuming there is no wasted time in splitting candles and lighting fires, the candles will all eventually burn out completely in 15 minutes. Simply explained, the whole candle will burn out in 15 minutes because you will always have four fires burning simultaneously. This is similar to the 30 minutes solution: at any time, your candle will be burning two fires, so it runs out of fuel twice as fast. In this solution, your candle is running out of fuel 4 times as fast, and therefore your fuel lasts a fourth of an hour. In general, if you had multiple children candles, you split a remaining candle every time one of them burns out in order to maintain the same number of fires alive to consume the total fuel.\\n\\nThe table below shows the general pattern of parts and fires needed to achieve a given burning time in minutes for one candle. Parts, in this case, means the number of parts you are splitting the initial candle into, and does not account for the times you recursively break up the child candles.\\n\\n<table>\\n  <tr>\\n    <th>Parts</th>\\n    <th>Fires</th> \\n    <th>Time</th>\\n  </tr>\\n  <tr>\\n    <td>1</td>\\n    <td>1</td> \\n    <td>60</td>\\n  </tr>\\n  <tr>\\n    <td>1</td>\\n    <td>2</td> \\n    <td>30</td>\\n  </tr>\\n  <tr>\\n    <td>2</td>\\n    <td>3</td> \\n    <td>20</td>\\n  </tr>\\n  <tr>\\n    <td>2</td>\\n    <td>4</td> \\n    <td>15</td>\\n  </tr>\\n  <tr>\\n    <td>3</td>\\n    <td>5</td> \\n    <td>12</td>\\n  </tr>\\n  <tr>\\n    <td>3</td>\\n    <td>6</td> \\n    <td>10</td>\\n  </tr>\\n</table>\\n\\n#### What time is it?\\nThe general equation for the number of fires $f$ needed to achieve a time $t$ in minutes is then simply $f=\\\\frac{60}t$. The number of parts $p$ needed given $f$ is then $p=\\\\lceil\\\\frac{f}2 \\\\rceil$. Keep in mind that this equation is valid only if we have one candle, and therefore $f\\\\in\\\\mathbb{Z^+}$. If such is the case, then the only exact times we are able to achieve with one candle are the quotients of dividing 60 by any positive integer. We can say that given a candle that normally burns (with a single flame) in $m$ minutes, the set of all solutions are in $\\\\\\\\{\\\\frac mz \\\\mid z\\\\in\\\\mathbb{Z^+}\\\\\\\\}$. So, knowing how the solution plays out, and how long one candle burns for, let's write a simple Python script to calculate how many parts the initial candle needs to be split into, and how many fires need to be simultaneously lit in order to achieve a desired time. We have two arguments to pass in: `burn_rate` (the time it takes to burn the whole candle with a single fire) and `target_time` (a time you'd like to waste playing with candles). The program should output a tuple: the former number will be the parts to split into and the latter will be the number of fires to light between all those parts. These two pieces of information will get you as close to your `target_time` as possible without exceeding it. The code below demonstrates one way of achieving this.\\n\\n```language-python\\nimport math\\n\\ndef candle_waster(burn_rate, target_time):\\n  fires = math.ceil(burn_rate/target_time)\\n  parts = math.ceil(fires/2)\\n  if target_time > burn_rate:\\n    return \\\"Can't burn candle longer than burn_rate\\\"\\n  return parts, fires\\n    \\nprint(candle_waster(60,15))\\nprint(candle_waster(30,5))\\nprint(candle_waster(10,1))\\nprint(candle_waster(5,3))\\nprint(candle_waster(1,2))\\n```\\n```language-none\\n(2, 4)\\n(3, 6)\\n(5, 10)\\n(1, 2)\\nCan't burn candle longer than burn_rate\\n```\\nThat was the easier part. Let's figure out what times we're able to achieve with more than one candle.\\n\\n#### Lots and lots of wax\\n\\nSuppose now we have two candles that all have the same burn rate of $m$ minutes each. It is simple to see that we are able to achieve a maximum time of $2m$ minutes by using them in succession&mdash;that is, burning them one by one until we're done. In fact, these \\\"additive\\\" times are reached simply by adding any times $t\\\\_1$ and $t\\\\_2$ together such that $t\\\\_1, t\\\\_2 \\\\in S$, where $S = \\\\\\\\{\\\\frac mz \\\\mid z\\\\in\\\\mathbb{Z^+}\\\\\\\\}$ (the set of times possible with each candle of burn rate $m$). One can see that $\\\\lvert S \\\\rvert = \\\\infty$ because we haven't defined proper constraints for $z$. For our sake, we can define a maximum number of fires $e$ allowed for each candle (meaning no one candle can have more than $e$ fires ablaze at one time, which limits the magnitude of $S$ to a finite number). Furthermore, let's define $S\\\\_{m,e}$ to mean **the set of times achievable with a single candle of burn rate $m$ and max fires of $e$**:\\n$$\\nS\\\\_{m,e} = \\\\\\\\{\\\\frac mz \\\\mid z\\\\in\\\\mathbb{Z^+}, 1 \\\\leq z \\\\leq e \\\\\\\\}\\n$$\\nAs an example, set $m=60, e=3$. Thus, the two candles are able to produce the times in $S\\\\_{60,3}$ *individually*. This means that, by itself, any one of the two candles can produce any of these times in the set $S\\\\_{60,3} = \\\\\\\\{60,30,20\\\\\\\\}$. Utilizing both of them, however, produces a wider range of possible times.\\n\\n---\\n\\nThe set of possible times of using *both* candles is expanded because you have more choices as to how you go about lighting, splitting, and delaying each candle. One set of possibilities is the option of successively lighting each candle after the last one burns out. Let's call this set of times $T\\\\_{sc}$. In our example above, each candle is able to burn for either 60, 30, or 20 minutes each. We see that if we burn the first candle for 60 minutes, *then* burn the second for 60 minutes, we've produced a new possible time of 120 minutes. Each of the times in $S\\\\_{60,3}$ is added to all possible times also in the same set $S\\\\_{60,3}$. As such, we are left with $T\\\\_{sc}$ containing the set of numbers which result from the [Minkowski addition](https://en.wikipedia.org/wiki/Minkowski_addition) (or direct sum) of $S\\\\_{60,3}$ and itself. It's intuitive to see how the times form from successive burning, and we demonstrate it below with all possible cases of said process. Let the first and second candles, along with their remaining burn times, be $c\\\\_{1},c\\\\_{2},b\\\\_{1},b\\\\_{2}$, respectively.\\n\\nSuccessive burning:\\n\\n* (Case 1) $c\\\\_{1}$ burns for $b\\\\_{1}=60$ minutes, then\\n    * (1A) $c\\\\_{2}$ burns for $b\\\\_{2}=60$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 120 minutes.\\n    * (1B) $c\\\\_{2}$ burns for $b\\\\_{2}=30$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 90 minutes.\\n    * (1C) $c\\\\_{2}$ burns for $b\\\\_{2}=20$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 80 minutes.\\n\\n* (Case 2) $c\\\\_{1}$ burns for $b\\\\_{1}=30$ minutes, then\\n    * (2A) $c\\\\_{2}$ burns for $b\\\\_{2}=60$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 90 minutes.\\n    * (2B) $c\\\\_{2}$ burns for $b\\\\_{2}=30$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 60 minutes.\\n    * (2C) $c\\\\_{2}$ burns for $b\\\\_{2}=20$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 50 minutes.\\n\\n* (Case 3) $c\\\\_{1}$ burns for $b\\\\_{1}=20$ minutes, then\\n    * (3A) $c\\\\_{2}$ burns for $b\\\\_{2}=60$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 80 minutes.\\n    * (3B) $c\\\\_{2}$ burns for $b\\\\_{2}=30$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 50 minutes.\\n    * (3C) $c\\\\_{2}$ burns for $b\\\\_{2}=20$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 40 minutes.\\n\\nThus, $T\\\\_{sc} = \\\\\\\\{120,90,80,60,50,40\\\\\\\\}$ given two candles, with $m=60, e=3$. The other option of discovering time possibilities is the idea of simultaneously burning the candles. This method is a bit trickier. Recall that towards the start of this post was a solution for 45 minutes that involved two candles: the first candle was lit on one end and the second was lit on both ends. Both burned for 30 minutes (until the second one burned out) and the first one was left with 30 remaining minutes of wax (30 minutes have also passed at this point). We ensured the remaining one had two fires ablaze and thus burned twice as fast with 30 minutes of fuel left, which means it burned for 15 minutes. The 30 minutes from the simultaneous burning and the 15 from the remainder burning produced 45 total minutes. This was possible because we were able to reduce the first candle's burn rate down by any attainable time of the second candle, and from there we solved the sub-problem of getting 15 minutes using an $m=30$ candle. Let $T\\\\_{sim}$ be the set of times that result from simultaneously burning both candles and adding on the time possibility set of the remaining candle. Each case of these simultaneously burnings are outline below.\\n\\nSimultaneous (then remainder) burning:\\n\\n* (Case 1) Light $c\\\\_{1}$ with 1 fire ($b\\\\_{1}=60$) along with\\n    * (1A) $c\\\\_{2}$ with 1 fire ($b\\\\_{2}=60$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=0$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 60+\\\\\\\\{0\\\\\\\\} = \\\\\\\\{60\\\\\\\\}$\\n    * (1B) $c\\\\_{2}$ with 2 fires ($b\\\\_{2}=30$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=30$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 30+\\\\\\\\{30,15,10\\\\\\\\} = \\\\\\\\{60,45,40\\\\\\\\}$\\n    * (1C) $c\\\\_{2}$ with 3 fires ($b\\\\_{2}=20$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=40$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 20+\\\\\\\\{40,20,\\\\frac{40}3\\\\\\\\} = \\\\\\\\{60,40,33\\\\frac13\\\\\\\\}$\\n\\n* (Case 2) Light $c\\\\_{1}$ with 2 fires ($b\\\\_{1}=30$) along with\\n    * (2A) $c\\\\_{2}$ with 1 fire ($b\\\\_{2}=60$) $\\\\rightarrow$ same as case 1B.\\n    * (2B) $c\\\\_{2}$ with 2 fires ($b\\\\_{2}=30$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=0$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 30+\\\\\\\\{0\\\\\\\\} = \\\\\\\\{30\\\\\\\\}$\\n    * (2C) $c\\\\_{2}$ with 3 fires ($b\\\\_{2}=20$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=10$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 20+\\\\\\\\{10,5,\\\\frac{10}3\\\\\\\\} = \\\\\\\\{30,25,23\\\\frac13\\\\\\\\}$\\n\\n* (Case 3) Light $c\\\\_{1}$ with 3 fires ($b\\\\_{1}=20$) along with\\n    * (3A) $c\\\\_{2}$ with 1 fire ($b\\\\_{2}=60$) $\\\\rightarrow$ same as case 1C.\\n    * (3B) $c\\\\_{2}$ with 2 fires ($b\\\\_{2}=30$) $\\\\rightarrow$ same as case 2C.\\n    * (3C) $c\\\\_{2}$ with 3 fires ($b\\\\_{2}=20$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=0$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 20+\\\\\\\\{0\\\\\\\\} = \\\\\\\\{20\\\\\\\\}$\\n\\nThus, $T\\\\_{sim} = \\\\\\\\{60,45,40,33\\\\frac13,30,25,23\\\\frac13,20\\\\\\\\}$ given two candles, with $m=60, e=3$. We have then that given these two candles, we're about to produce the final set of times $T$:\\n$$\\nT = S\\\\_{60,3} \\\\cup T\\\\_{sc} \\\\cup T\\\\_{sim}=\\\\\\\\{120,90,80,60,50,45,40,33\\\\frac13,30,25,23\\\\frac13,20\\\\\\\\}\\n$$\\nNow, what would happen with three candles? The short story is, the successive times of three candles with the same burn rate and max fires is simply the direct sum of our previous times of 2 candles $T$ with another $S\\\\_{60,3}$. Similarly, the possible simultaneous times of this group would utilize the same procedure we used for $S\\\\_{60,3}$, except now we find all possible cases using the expanded set of times $T$ instead. Let's define a few functions back in Python to help us figure out all the times given a number of `candles`, a `burn_rate`, and `max_fires`. The function `times_succession()` accepts two sets and returns the direct sum of those two sets. The function `times_simul()` accepts two sets and max fires, and returns the set of times as described in our simultaneous and remainder burning above. `times_of_one_candle()` simply returns the set of times possible with one candle given its burn rate and max fires.\\n\\n```language-python\\ndef times_succession(set_one, set_two):\\n    t_sc = set([])\\n\\n    for x in set_one:\\n        for y in set_two:\\n            t_sc |= {round(x + y, 4)}\\n\\n    return t_sc\\n\\n\\ndef times_simul(set_one, set_two, max_fires):\\n    t_sim = set([])\\n\\n    for x in set_one:\\n        for y in set_two:\\n            if x >= y:\\n                remaining_time = x - y\\n                t = times_succession({round(y, 4)}, times_of_one_candle(remaining_time, max_fires))\\n                t_sim |= t\\n\\n    return t_sim\\n\\n\\ndef times_of_one_candle(burn_rate, max_fires):\\n    s = set([])\\n\\n    for x in range(1, max_fires + 1):\\n        s |= {burn_rate / x}\\n\\n    return s\\n```\\n\\nWe now have functions that return all the subsets needed for our equation in order to find all the possible sets given the correct parameters. Let's write a function `all_times()`, which takes in our three arguments `candles`, `burn_rate`, and `max_fires` and calls our helper functions to return the set of all times that we are able to achieve with these constraints.\\n\\n```language-python\\ndef all_times(candles, burn_rate, max_fires):\\n    if candles == 0 or burn_rate == 0 or max_fires == 0:\\n        return set([])\\n    if candles == 1:\\n        return times_of_one_candle(burn_rate, max_fires)\\n\\n    times = set([])\\n\\n    s = times_of_one_candle(burn_rate, max_fires)\\n    times |= s\\n\\n    for c in range(1, candles):\\n        t_sc = times_succession(times, s)\\n        t_sim = times_simul(times, s, max_fires)\\n        times |= (t_sc | t_sim)\\n\\n    return times\\n\\ns = sorted(all_times(2, 60, 3), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n    \\ns = sorted(all_times(3, 60, 4), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n    \\ns = sorted(all_times(4, 100, 5), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n    \\ns = sorted(all_times(5, 100, 6), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n    \\ns = sorted(all_times(6, 200, 5), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n```\\n```language-none\\n[120.0, 90.0, 80.0, 60.0, 50.0, 45.0, 40.0, 33.3333, 30.0, 25.0, 23.3333, 20.0]\\nMagnitude: 12\\n[180.0, 150.0, 140.0, 120.0, 110.0, 105.0, 100.0, 93.3333, 90.0, 85.0, 83.3333, ...]\\nMagnitude: 100\\n[400.0, 350.0, 333.3333, 325.0, 300.0, 283.3333, 275.0, 266.6667, 266.6666, ...]\\nMagnitude: 2414\\n[500.0, 450.0, 433.3333, 425.0, 420.0, 400.0, 383.3333, 375.0, 370.0, 366.6667, ...]\\nMagnitude: 30885\\n[1200.0, 1100.0, 1066.6667, 1050.0, 1040.0, 1000.0, 966.6667, 950.0, 940.0, ...]\\nMagnitude: 75430\\n```\\n\\nThe magnitude of each set displayed is simply the number of possible times. At this point, it's trivial to search for a time goal by reversing the process such that the script gives us `candles`, `burn_rate`, and/or `max_fires` given an input time goal.\\n\\nFinally, it is also pretty trivial to imagine how many hours and chances ago I should have stopped trying to dive into this problem, but we both know those attempts were futile.\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]]}","created_at_ts":1550397352734,"created_at":"2019-02-17T09:55:52.000Z"}],"permissions":[{"id":"5be33e8f2ec3980b24cfe9d7","name":"Export database","object_type":"db","action_type":"exportContent","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9d8","name":"Import database","object_type":"db","action_type":"importContent","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9d9","name":"Delete all content","object_type":"db","action_type":"deleteAllContent","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9da","name":"Send mail","object_type":"mail","action_type":"send","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9db","name":"Browse notifications","object_type":"notification","action_type":"browse","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9dc","name":"Add notifications","object_type":"notification","action_type":"add","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9dd","name":"Delete notifications","object_type":"notification","action_type":"destroy","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9de","name":"Browse posts","object_type":"post","action_type":"browse","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9df","name":"Read posts","object_type":"post","action_type":"read","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9e0","name":"Edit posts","object_type":"post","action_type":"edit","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9e1","name":"Add posts","object_type":"post","action_type":"add","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9e2","name":"Delete posts","object_type":"post","action_type":"destroy","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9e3","name":"Browse settings","object_type":"setting","action_type":"browse","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9e4","name":"Read settings","object_type":"setting","action_type":"read","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9e5","name":"Edit settings","object_type":"setting","action_type":"edit","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9e6","name":"Generate slugs","object_type":"slug","action_type":"generate","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9e7","name":"Browse tags","object_type":"tag","action_type":"browse","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9e8","name":"Read tags","object_type":"tag","action_type":"read","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9e9","name":"Edit tags","object_type":"tag","action_type":"edit","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9ea","name":"Add tags","object_type":"tag","action_type":"add","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9eb","name":"Delete tags","object_type":"tag","action_type":"destroy","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9ec","name":"Browse themes","object_type":"theme","action_type":"browse","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9ed","name":"Edit themes","object_type":"theme","action_type":"edit","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9ee","name":"Activate themes","object_type":"theme","action_type":"activate","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9ef","name":"Upload themes","object_type":"theme","action_type":"add","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9f0","name":"Download themes","object_type":"theme","action_type":"read","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9f1","name":"Delete themes","object_type":"theme","action_type":"destroy","object_id":null,"created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfe9f2","name":"Browse users","object_type":"user","action_type":"browse","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfe9f3","name":"Read users","object_type":"user","action_type":"read","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfe9f4","name":"Edit users","object_type":"user","action_type":"edit","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfe9f5","name":"Add users","object_type":"user","action_type":"add","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfe9f6","name":"Delete users","object_type":"user","action_type":"destroy","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfe9f7","name":"Assign a role","object_type":"role","action_type":"assign","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfe9f8","name":"Browse roles","object_type":"role","action_type":"browse","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfe9f9","name":"Browse clients","object_type":"client","action_type":"browse","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfe9fa","name":"Read clients","object_type":"client","action_type":"read","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfe9fb","name":"Edit clients","object_type":"client","action_type":"edit","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfe9fc","name":"Add clients","object_type":"client","action_type":"add","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfe9fd","name":"Delete clients","object_type":"client","action_type":"destroy","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfe9fe","name":"Browse subscribers","object_type":"subscriber","action_type":"browse","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfe9ff","name":"Read subscribers","object_type":"subscriber","action_type":"read","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea00","name":"Edit subscribers","object_type":"subscriber","action_type":"edit","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea01","name":"Add subscribers","object_type":"subscriber","action_type":"add","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea02","name":"Delete subscribers","object_type":"subscriber","action_type":"destroy","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea03","name":"Browse invites","object_type":"invite","action_type":"browse","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea04","name":"Read invites","object_type":"invite","action_type":"read","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea05","name":"Edit invites","object_type":"invite","action_type":"edit","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea06","name":"Add invites","object_type":"invite","action_type":"add","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea07","name":"Delete invites","object_type":"invite","action_type":"destroy","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea08","name":"Download redirects","object_type":"redirect","action_type":"download","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea09","name":"Upload redirects","object_type":"redirect","action_type":"upload","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea0a","name":"Add webhooks","object_type":"webhook","action_type":"add","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea0b","name":"Edit webhooks","object_type":"webhook","action_type":"edit","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea0c","name":"Delete webhooks","object_type":"webhook","action_type":"destroy","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea0d","name":"Browse integrations","object_type":"integration","action_type":"browse","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea0e","name":"Read integrations","object_type":"integration","action_type":"read","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea0f","name":"Edit integrations","object_type":"integration","action_type":"edit","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea10","name":"Add integrations","object_type":"integration","action_type":"add","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea11","name":"Delete integrations","object_type":"integration","action_type":"destroy","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea12","name":"Browse API keys","object_type":"api_key","action_type":"browse","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea13","name":"Read API keys","object_type":"api_key","action_type":"read","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea14","name":"Edit API keys","object_type":"api_key","action_type":"edit","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea15","name":"Add API keys","object_type":"api_key","action_type":"add","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"},{"id":"5be33e902ec3980b24cfea16","name":"Delete API keys","object_type":"api_key","action_type":"destroy","object_id":null,"created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2018-11-07T19:35:44.000Z","updated_by":"1"}],"permissions_apps":[],"permissions_roles":[{"id":"5be33e912ec3980b24cfea26","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9d7"},{"id":"5be33e912ec3980b24cfea27","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9d8"},{"id":"5be33e912ec3980b24cfea28","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9d9"},{"id":"5be33e912ec3980b24cfea29","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9da"},{"id":"5be33e912ec3980b24cfea2a","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9db"},{"id":"5be33e912ec3980b24cfea2b","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9dc"},{"id":"5be33e912ec3980b24cfea2c","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9dd"},{"id":"5be33e912ec3980b24cfea2d","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9de"},{"id":"5be33e912ec3980b24cfea2e","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9df"},{"id":"5be33e912ec3980b24cfea2f","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9e0"},{"id":"5be33e912ec3980b24cfea30","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9e1"},{"id":"5be33e912ec3980b24cfea31","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9e2"},{"id":"5be33e912ec3980b24cfea32","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9e3"},{"id":"5be33e912ec3980b24cfea33","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9e4"},{"id":"5be33e912ec3980b24cfea34","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9e5"},{"id":"5be33e912ec3980b24cfea35","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9e6"},{"id":"5be33e912ec3980b24cfea36","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9e7"},{"id":"5be33e912ec3980b24cfea37","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9e8"},{"id":"5be33e912ec3980b24cfea38","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9e9"},{"id":"5be33e912ec3980b24cfea39","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9ea"},{"id":"5be33e912ec3980b24cfea3a","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9eb"},{"id":"5be33e912ec3980b24cfea3b","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9ec"},{"id":"5be33e912ec3980b24cfea3c","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9ed"},{"id":"5be33e912ec3980b24cfea3d","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9ee"},{"id":"5be33e912ec3980b24cfea3e","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9ef"},{"id":"5be33e912ec3980b24cfea3f","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9f0"},{"id":"5be33e912ec3980b24cfea40","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e8f2ec3980b24cfe9f1"},{"id":"5be33e912ec3980b24cfea41","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfe9f2"},{"id":"5be33e912ec3980b24cfea42","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfe9f3"},{"id":"5be33e912ec3980b24cfea43","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfe9f4"},{"id":"5be33e912ec3980b24cfea44","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfe9f5"},{"id":"5be33e912ec3980b24cfea45","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfe9f6"},{"id":"5be33e912ec3980b24cfea46","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfe9f7"},{"id":"5be33e912ec3980b24cfea47","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfe9f8"},{"id":"5be33e912ec3980b24cfea48","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfe9f9"},{"id":"5be33e912ec3980b24cfea49","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfe9fa"},{"id":"5be33e912ec3980b24cfea4a","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfe9fb"},{"id":"5be33e912ec3980b24cfea4b","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfe9fc"},{"id":"5be33e912ec3980b24cfea4c","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfe9fd"},{"id":"5be33e912ec3980b24cfea4d","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfe9fe"},{"id":"5be33e912ec3980b24cfea4e","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfe9ff"},{"id":"5be33e912ec3980b24cfea4f","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea00"},{"id":"5be33e912ec3980b24cfea50","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea01"},{"id":"5be33e912ec3980b24cfea51","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea02"},{"id":"5be33e922ec3980b24cfea52","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea03"},{"id":"5be33e922ec3980b24cfea53","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea04"},{"id":"5be33e922ec3980b24cfea54","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea05"},{"id":"5be33e922ec3980b24cfea55","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea06"},{"id":"5be33e922ec3980b24cfea56","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea07"},{"id":"5be33e922ec3980b24cfea57","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea08"},{"id":"5be33e922ec3980b24cfea58","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea09"},{"id":"5be33e922ec3980b24cfea59","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea0a"},{"id":"5be33e922ec3980b24cfea5a","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea0b"},{"id":"5be33e922ec3980b24cfea5b","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea0c"},{"id":"5be33e922ec3980b24cfea5c","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea0d"},{"id":"5be33e922ec3980b24cfea5d","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea0e"},{"id":"5be33e922ec3980b24cfea5e","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea0f"},{"id":"5be33e922ec3980b24cfea5f","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea10"},{"id":"5be33e922ec3980b24cfea60","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea11"},{"id":"5be33e922ec3980b24cfea61","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea12"},{"id":"5be33e922ec3980b24cfea62","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea13"},{"id":"5be33e922ec3980b24cfea63","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea14"},{"id":"5be33e922ec3980b24cfea64","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea15"},{"id":"5be33e922ec3980b24cfea65","role_id":"5be33e8f2ec3980b24cfe9d1","permission_id":"5be33e902ec3980b24cfea16"},{"id":"5be33e922ec3980b24cfea66","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9da"},{"id":"5be33e922ec3980b24cfea67","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9db"},{"id":"5be33e922ec3980b24cfea68","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9dc"},{"id":"5be33e922ec3980b24cfea69","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9dd"},{"id":"5be33e922ec3980b24cfea6a","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9de"},{"id":"5be33e922ec3980b24cfea6b","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9df"},{"id":"5be33e922ec3980b24cfea6c","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9e0"},{"id":"5be33e922ec3980b24cfea6d","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9e1"},{"id":"5be33e922ec3980b24cfea6e","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9e2"},{"id":"5be33e922ec3980b24cfea6f","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9e3"},{"id":"5be33e922ec3980b24cfea70","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9e4"},{"id":"5be33e922ec3980b24cfea71","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9e5"},{"id":"5be33e922ec3980b24cfea72","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9e6"},{"id":"5be33e922ec3980b24cfea73","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9e7"},{"id":"5be33e922ec3980b24cfea74","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9e8"},{"id":"5be33e922ec3980b24cfea75","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9e9"},{"id":"5be33e922ec3980b24cfea76","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9ea"},{"id":"5be33e922ec3980b24cfea77","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9eb"},{"id":"5be33e922ec3980b24cfea78","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9ec"},{"id":"5be33e922ec3980b24cfea79","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9ed"},{"id":"5be33e922ec3980b24cfea7a","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9ee"},{"id":"5be33e922ec3980b24cfea7b","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9ef"},{"id":"5be33e922ec3980b24cfea7c","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9f0"},{"id":"5be33e922ec3980b24cfea7d","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e8f2ec3980b24cfe9f1"},{"id":"5be33e922ec3980b24cfea7e","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfe9f2"},{"id":"5be33e922ec3980b24cfea7f","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfe9f3"},{"id":"5be33e922ec3980b24cfea80","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfe9f4"},{"id":"5be33e922ec3980b24cfea81","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfe9f5"},{"id":"5be33e922ec3980b24cfea82","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfe9f6"},{"id":"5be33e922ec3980b24cfea83","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfe9f7"},{"id":"5be33e922ec3980b24cfea84","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfe9f8"},{"id":"5be33e922ec3980b24cfea85","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfe9f9"},{"id":"5be33e922ec3980b24cfea86","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfe9fa"},{"id":"5be33e922ec3980b24cfea87","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfe9fb"},{"id":"5be33e922ec3980b24cfea88","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfe9fc"},{"id":"5be33e922ec3980b24cfea89","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfe9fd"},{"id":"5be33e922ec3980b24cfea8a","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfe9fe"},{"id":"5be33e922ec3980b24cfea8b","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfe9ff"},{"id":"5be33e922ec3980b24cfea8c","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfea00"},{"id":"5be33e922ec3980b24cfea8d","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfea01"},{"id":"5be33e922ec3980b24cfea8e","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfea02"},{"id":"5be33e922ec3980b24cfea8f","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfea03"},{"id":"5be33e922ec3980b24cfea90","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfea04"},{"id":"5be33e922ec3980b24cfea91","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfea05"},{"id":"5be33e922ec3980b24cfea92","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfea06"},{"id":"5be33e922ec3980b24cfea93","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfea07"},{"id":"5be33e922ec3980b24cfea94","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfea08"},{"id":"5be33e922ec3980b24cfea95","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfea09"},{"id":"5be33e922ec3980b24cfea96","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfea0a"},{"id":"5be33e922ec3980b24cfea97","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfea0b"},{"id":"5be33e922ec3980b24cfea98","role_id":"5be33e8f2ec3980b24cfe9d6","permission_id":"5be33e902ec3980b24cfea0c"},{"id":"5be33e922ec3980b24cfea99","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e8f2ec3980b24cfe9de"},{"id":"5be33e922ec3980b24cfea9a","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e8f2ec3980b24cfe9df"},{"id":"5be33e922ec3980b24cfea9b","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e8f2ec3980b24cfe9e0"},{"id":"5be33e922ec3980b24cfea9c","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e8f2ec3980b24cfe9e1"},{"id":"5be33e922ec3980b24cfea9d","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e8f2ec3980b24cfe9e2"},{"id":"5be33e922ec3980b24cfea9e","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e8f2ec3980b24cfe9e3"},{"id":"5be33e922ec3980b24cfea9f","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e8f2ec3980b24cfe9e4"},{"id":"5be33e922ec3980b24cfeaa0","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e8f2ec3980b24cfe9e6"},{"id":"5be33e922ec3980b24cfeaa1","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e8f2ec3980b24cfe9e7"},{"id":"5be33e922ec3980b24cfeaa2","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e8f2ec3980b24cfe9e8"},{"id":"5be33e922ec3980b24cfeaa3","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e8f2ec3980b24cfe9e9"},{"id":"5be33e922ec3980b24cfeaa4","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e8f2ec3980b24cfe9ea"},{"id":"5be33e922ec3980b24cfeaa5","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e8f2ec3980b24cfe9eb"},{"id":"5be33e922ec3980b24cfeaa6","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e902ec3980b24cfe9f2"},{"id":"5be33e922ec3980b24cfeaa7","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e902ec3980b24cfe9f3"},{"id":"5be33e922ec3980b24cfeaa8","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e902ec3980b24cfe9f4"},{"id":"5be33e922ec3980b24cfeaa9","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e902ec3980b24cfe9f5"},{"id":"5be33e922ec3980b24cfeaaa","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e902ec3980b24cfe9f6"},{"id":"5be33e922ec3980b24cfeaab","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e902ec3980b24cfe9f7"},{"id":"5be33e922ec3980b24cfeaac","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e902ec3980b24cfe9f8"},{"id":"5be33e922ec3980b24cfeaad","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e902ec3980b24cfe9f9"},{"id":"5be33e922ec3980b24cfeaae","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e902ec3980b24cfe9fa"},{"id":"5be33e922ec3980b24cfeaaf","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e902ec3980b24cfe9fb"},{"id":"5be33e922ec3980b24cfeab0","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e902ec3980b24cfe9fc"},{"id":"5be33e922ec3980b24cfeab1","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e902ec3980b24cfe9fd"},{"id":"5be33e922ec3980b24cfeab2","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e902ec3980b24cfea01"},{"id":"5be33e922ec3980b24cfeab3","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e902ec3980b24cfea03"},{"id":"5be33e922ec3980b24cfeab4","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e902ec3980b24cfea04"},{"id":"5be33e922ec3980b24cfeab5","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e902ec3980b24cfea05"},{"id":"5be33e922ec3980b24cfeab6","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e902ec3980b24cfea06"},{"id":"5be33e922ec3980b24cfeab7","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e902ec3980b24cfea07"},{"id":"5be33e922ec3980b24cfeab8","role_id":"5be33e8f2ec3980b24cfe9d2","permission_id":"5be33e8f2ec3980b24cfe9ec"},{"id":"5be33e922ec3980b24cfeab9","role_id":"5be33e8f2ec3980b24cfe9d3","permission_id":"5be33e8f2ec3980b24cfe9de"},{"id":"5be33e922ec3980b24cfeaba","role_id":"5be33e8f2ec3980b24cfe9d3","permission_id":"5be33e8f2ec3980b24cfe9df"},{"id":"5be33e922ec3980b24cfeabb","role_id":"5be33e8f2ec3980b24cfe9d3","permission_id":"5be33e8f2ec3980b24cfe9e1"},{"id":"5be33e922ec3980b24cfeabc","role_id":"5be33e8f2ec3980b24cfe9d3","permission_id":"5be33e8f2ec3980b24cfe9e3"},{"id":"5be33e922ec3980b24cfeabd","role_id":"5be33e8f2ec3980b24cfe9d3","permission_id":"5be33e8f2ec3980b24cfe9e4"},{"id":"5be33e922ec3980b24cfeabe","role_id":"5be33e8f2ec3980b24cfe9d3","permission_id":"5be33e8f2ec3980b24cfe9e6"},{"id":"5be33e922ec3980b24cfeabf","role_id":"5be33e8f2ec3980b24cfe9d3","permission_id":"5be33e8f2ec3980b24cfe9e7"},{"id":"5be33e922ec3980b24cfeac0","role_id":"5be33e8f2ec3980b24cfe9d3","permission_id":"5be33e8f2ec3980b24cfe9e8"},{"id":"5be33e922ec3980b24cfeac1","role_id":"5be33e8f2ec3980b24cfe9d3","permission_id":"5be33e8f2ec3980b24cfe9ea"},{"id":"5be33e922ec3980b24cfeac2","role_id":"5be33e8f2ec3980b24cfe9d3","permission_id":"5be33e902ec3980b24cfe9f2"},{"id":"5be33e922ec3980b24cfeac3","role_id":"5be33e8f2ec3980b24cfe9d3","permission_id":"5be33e902ec3980b24cfe9f3"},{"id":"5be33e922ec3980b24cfeac4","role_id":"5be33e8f2ec3980b24cfe9d3","permission_id":"5be33e902ec3980b24cfe9f8"},{"id":"5be33e922ec3980b24cfeac5","role_id":"5be33e8f2ec3980b24cfe9d3","permission_id":"5be33e902ec3980b24cfe9f9"},{"id":"5be33e922ec3980b24cfeac6","role_id":"5be33e8f2ec3980b24cfe9d3","permission_id":"5be33e902ec3980b24cfe9fa"},{"id":"5be33e922ec3980b24cfeac7","role_id":"5be33e8f2ec3980b24cfe9d3","permission_id":"5be33e902ec3980b24cfe9fb"},{"id":"5be33e922ec3980b24cfeac8","role_id":"5be33e8f2ec3980b24cfe9d3","permission_id":"5be33e902ec3980b24cfe9fc"},{"id":"5be33e922ec3980b24cfeac9","role_id":"5be33e8f2ec3980b24cfe9d3","permission_id":"5be33e902ec3980b24cfe9fd"},{"id":"5be33e922ec3980b24cfeaca","role_id":"5be33e8f2ec3980b24cfe9d3","permission_id":"5be33e902ec3980b24cfea01"},{"id":"5be33e922ec3980b24cfeacb","role_id":"5be33e8f2ec3980b24cfe9d3","permission_id":"5be33e8f2ec3980b24cfe9ec"},{"id":"5be33e922ec3980b24cfeacc","role_id":"5be33e8f2ec3980b24cfe9d4","permission_id":"5be33e8f2ec3980b24cfe9de"},{"id":"5be33e922ec3980b24cfeacd","role_id":"5be33e8f2ec3980b24cfe9d4","permission_id":"5be33e8f2ec3980b24cfe9df"},{"id":"5be33e922ec3980b24cfeace","role_id":"5be33e8f2ec3980b24cfe9d4","permission_id":"5be33e8f2ec3980b24cfe9e1"},{"id":"5be33e922ec3980b24cfeacf","role_id":"5be33e8f2ec3980b24cfe9d4","permission_id":"5be33e8f2ec3980b24cfe9e3"},{"id":"5be33e922ec3980b24cfead0","role_id":"5be33e8f2ec3980b24cfe9d4","permission_id":"5be33e8f2ec3980b24cfe9e4"},{"id":"5be33e922ec3980b24cfead1","role_id":"5be33e8f2ec3980b24cfe9d4","permission_id":"5be33e8f2ec3980b24cfe9e6"},{"id":"5be33e922ec3980b24cfead2","role_id":"5be33e8f2ec3980b24cfe9d4","permission_id":"5be33e8f2ec3980b24cfe9e7"},{"id":"5be33e922ec3980b24cfead3","role_id":"5be33e8f2ec3980b24cfe9d4","permission_id":"5be33e8f2ec3980b24cfe9e8"},{"id":"5be33e922ec3980b24cfead4","role_id":"5be33e8f2ec3980b24cfe9d4","permission_id":"5be33e902ec3980b24cfe9f2"},{"id":"5be33e922ec3980b24cfead5","role_id":"5be33e8f2ec3980b24cfe9d4","permission_id":"5be33e902ec3980b24cfe9f3"},{"id":"5be33e922ec3980b24cfead6","role_id":"5be33e8f2ec3980b24cfe9d4","permission_id":"5be33e902ec3980b24cfe9f8"},{"id":"5be33e922ec3980b24cfead7","role_id":"5be33e8f2ec3980b24cfe9d4","permission_id":"5be33e902ec3980b24cfe9f9"},{"id":"5be33e922ec3980b24cfead8","role_id":"5be33e8f2ec3980b24cfe9d4","permission_id":"5be33e902ec3980b24cfe9fa"},{"id":"5be33e922ec3980b24cfead9","role_id":"5be33e8f2ec3980b24cfe9d4","permission_id":"5be33e902ec3980b24cfe9fb"},{"id":"5be33e922ec3980b24cfeada","role_id":"5be33e8f2ec3980b24cfe9d4","permission_id":"5be33e902ec3980b24cfe9fc"},{"id":"5be33e922ec3980b24cfeadb","role_id":"5be33e8f2ec3980b24cfe9d4","permission_id":"5be33e902ec3980b24cfe9fd"},{"id":"5be33e922ec3980b24cfeadc","role_id":"5be33e8f2ec3980b24cfe9d4","permission_id":"5be33e902ec3980b24cfea01"},{"id":"5be33e922ec3980b24cfeadd","role_id":"5be33e8f2ec3980b24cfe9d4","permission_id":"5be33e8f2ec3980b24cfe9ec"}],"permissions_users":[],"posts":[{"id":"5be78bb59686370eba85dc50","uuid":"af6fc2db-b515-49a8-a0ba-d25b6390d8b0","title":"Hacking Facebook Instant Games with Requests","slug":"hacking-facebook-instant-games-with-requests","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"Facebook recently introduced a whole new range of [Instant Games](https://messenger.fb.com/blog/instant-games-now-on-messenger/) that can be played in their Messenger app, whether on your mobile device or on your desktop.\\n\\n####Introduction\\nNaturally, the ubiquitous introduction of these mini-games have caused every one of my group chats on Messenger to become filled with friends savagely competing for the best scores. The more popular of these games include *Endless Lake* and *Track and Field 100M*. The purpose of *Endless Lake* is to avoid gaps in the path that your character takes by single and double tapping in order for your sprite to jump, whereas *Track and Field 100M* challenges you to make your track star finish the race as fast as possible by quickly tapping the screen in succession.\\n\\n####The problem\\nThe problem is simple: how do we get to the top of the scoreboard without legitimately playing the game? In other words, how can we hack and exploit the way these games communicate with the Facebook servers that keep track and tally the scores of each player?\\n\\n####The other problem\\nThere's a moral dilemma in hacking anything. On one hand, you're essentially saving yourself a butt-load of time and stress by simply gaming the system, platform, protocol, what-have-you, and finding alternative methods of achieving what many people believe to be success. On the other hand, you have officially become the asshole of the group chat for doing this because it's entirely not fair for the legitimate players who actually do try very hard to get on the leaderboard. I try my hardest not to be that asshole but sometimes having fun should not turn into a debate of morality. Try your best not to lose friends in the heat of the moment, and all should be fine. Onwards!\\n\\n####Networking\\nThe first task is to find out exactly how the game conveys the end score to Facebook's servers. This is easily accomplished using [Chrome's network developer tool](https://developers.google.com/web/tools/chrome-devtools/network-performance/resource-loading). From here, we're able to observe, filter, and record any and all network activity, including requests, flowing to and from your browser. We clear all network activity before we start up one of our games and set it to record immediately before the final score is sent to their servers (either upon your character's death or the finish of the race, respectively). The results are as follows:\\n\\n![](/content/images/2017/06/network.jpg)\\n\\nFrom this one recorded session, there were 109 requests made. Most of these were for images (.png, .jpeg) files which contained thumbnails of other games and Facebook friends. However, the name of the .xhr files starting with \\\"?doc_id\\\" and \\\"graphqlbatch\\\" are of interest, as these are the only plausible ways that the servers could be receiving some kind of data (.xhr is short for XMLHttpRequest, which is an API used by a variety of languages used to transfer and modify XML data using HTTP between client and server). Looking at the preview of the first .xhr file, we see something promising: payload data.\\n\\n![](/content/images/2017/06/network2.jpg)\\n\\nThis payload holds all the information regarding a player, their current score, their leaderboard, their friend's leaderboards, etc. This is most likely the data that we're trying to manipulate before it's sent to the server for validation and insertion. Just to be sure, we take a look at the headers of this request.<br>\\n![](/content/images/2017/06/network3.jpg)<br>\\nWe run the request URL through a generic URL decoder, and separate out the parameters given in order to get the following data:\\n\\n```javascript\\ndoc_id=903271543141302  \\nvariables={\\\"data\\\":{  \\n    \\\"client_mutation_id\\\":\\\"0\\\",\\n    \\\"actor_id\\\":\\\"100000189902487\\\",\\n    \\\"game_id\\\":\\\"611307059053310\\\",\\n    \\\"score\\\":11,\\n    \\\"thread_id\\\":\\\"100000189902487\\\",\\n    \\\"story_id\\\":null,\\n    \\\"group_id\\\":null,\\n    \\\"send_admin\\\":false,\\n    \\\"session_id\\\":\\\"cf45dd18-0e1b-4bd8-b388-62913bdf75b3\\\"\\n}}\\ndpr=1  \\n```\\n\\nNow it's quite clear to see that this request is indeed sending information about the exact game, score, group chat, and other key pieces of data to their endpoint at `https://www.messenger.com/webgraphql/mutation/`. Of course, one might think to simply make a copy of this request and send it along, with just a slight modification to the variable `score`. But this requires too much work; we'd have to get the request headers and query string parameters just right, and we're not too entirely sure if the `session_id` acts as an access token such that each one is uniquely generated to prevent this type of malicious request/score modification. Right, so now we know how the game is communicating with the servers and that it may be using some kind of key to prevent bad or unauthorized requests. This means we need to work with the request that the game generates naturally. How, then, do we stop the *original* request, modify it, and send it along again?\\n\\n####More Networking\\nThe answer to the previous question can be discovered with a simple Google search for \\\"http modify request\\\". One of these tools is called TamperChrome, and is an add-on/app for Chrome that lets users approve, modify, or decline requests as they are received. In other words, if the game had a phone and dialed Facebook to let them know the score a user received, TamperChrome acts as a redirected circuit on that phone line—it takes the data that was supposed to go directly to the server, modifies it, and sends it along as if nothing ever happened to it. Facebook's servers gladly accept this score as legitimate because everything else about the request is intact, including whatever unique key may have been generated. Running TamperChrome, we modify our score from a pathetic 11 points to an impressive 4011 points and approve this request to be sent along to the server.\\n\\n![](/content/images/2017/06/network-score-change.jpg)\\n\\n![](/content/images/2017/06/network-score-change2.jpg)\\n\\nThe changes are immediate: I've been catapulted to the top of the leaderboards:\\n\\n![](/content/images/2017/06/network-score-change3-new.jpg)\\n\\nRemember: with great power comes great responsibility. Please use this hack with that in mind.\"}]],\"markups\":[],\"sections\":[[10,0]]}","html":"<p>Facebook recently introduced a whole new range of <a href=\"https://messenger.fb.com/blog/instant-games-now-on-messenger/\">Instant Games</a> that can be played in their Messenger app, whether on your mobile device or on your desktop.</p>\n<h4 id=\"introduction\">Introduction</h4>\n<p>Naturally, the ubiquitous introduction of these mini-games have caused every one of my group chats on Messenger to become filled with friends savagely competing for the best scores. The more popular of these games include <em>Endless Lake</em> and <em>Track and Field 100M</em>. The purpose of <em>Endless Lake</em> is to avoid gaps in the path that your character takes by single and double tapping in order for your sprite to jump, whereas <em>Track and Field 100M</em> challenges you to make your track star finish the race as fast as possible by quickly tapping the screen in succession.</p>\n<h4 id=\"theproblem\">The problem</h4>\n<p>The problem is simple: how do we get to the top of the scoreboard without legitimately playing the game? In other words, how can we hack and exploit the way these games communicate with the Facebook servers that keep track and tally the scores of each player?</p>\n<h4 id=\"theotherproblem\">The other problem</h4>\n<p>There's a moral dilemma in hacking anything. On one hand, you're essentially saving yourself a butt-load of time and stress by simply gaming the system, platform, protocol, what-have-you, and finding alternative methods of achieving what many people believe to be success. On the other hand, you have officially become the asshole of the group chat for doing this because it's entirely not fair for the legitimate players who actually do try very hard to get on the leaderboard. I try my hardest not to be that asshole but sometimes having fun should not turn into a debate of morality. Try your best not to lose friends in the heat of the moment, and all should be fine. Onwards!</p>\n<h4 id=\"networking\">Networking</h4>\n<p>The first task is to find out exactly how the game conveys the end score to Facebook's servers. This is easily accomplished using <a href=\"https://developers.google.com/web/tools/chrome-devtools/network-performance/resource-loading\">Chrome's network developer tool</a>. From here, we're able to observe, filter, and record any and all network activity, including requests, flowing to and from your browser. We clear all network activity before we start up one of our games and set it to record immediately before the final score is sent to their servers (either upon your character's death or the finish of the race, respectively). The results are as follows:</p>\n<p><img src=\"/content/images/2017/06/network.jpg\" alt=\"\"></p>\n<p>From this one recorded session, there were 109 requests made. Most of these were for images (.png, .jpeg) files which contained thumbnails of other games and Facebook friends. However, the name of the .xhr files starting with &quot;?doc_id&quot; and &quot;graphqlbatch&quot; are of interest, as these are the only plausible ways that the servers could be receiving some kind of data (.xhr is short for XMLHttpRequest, which is an API used by a variety of languages used to transfer and modify XML data using HTTP between client and server). Looking at the preview of the first .xhr file, we see something promising: payload data.</p>\n<p><img src=\"/content/images/2017/06/network2.jpg\" alt=\"\"></p>\n<p>This payload holds all the information regarding a player, their current score, their leaderboard, their friend's leaderboards, etc. This is most likely the data that we're trying to manipulate before it's sent to the server for validation and insertion. Just to be sure, we take a look at the headers of this request.<br><br>\n<img src=\"/content/images/2017/06/network3.jpg\" alt=\"\"><br><br>\nWe run the request URL through a generic URL decoder, and separate out the parameters given in order to get the following data:</p>\n<pre><code class=\"language-javascript\">doc_id=903271543141302  \nvariables={&quot;data&quot;:{  \n    &quot;client_mutation_id&quot;:&quot;0&quot;,\n    &quot;actor_id&quot;:&quot;100000189902487&quot;,\n    &quot;game_id&quot;:&quot;611307059053310&quot;,\n    &quot;score&quot;:11,\n    &quot;thread_id&quot;:&quot;100000189902487&quot;,\n    &quot;story_id&quot;:null,\n    &quot;group_id&quot;:null,\n    &quot;send_admin&quot;:false,\n    &quot;session_id&quot;:&quot;cf45dd18-0e1b-4bd8-b388-62913bdf75b3&quot;\n}}\ndpr=1  \n</code></pre>\n<p>Now it's quite clear to see that this request is indeed sending information about the exact game, score, group chat, and other key pieces of data to their endpoint at <code>https://www.messenger.com/webgraphql/mutation/</code>. Of course, one might think to simply make a copy of this request and send it along, with just a slight modification to the variable <code>score</code>. But this requires too much work; we'd have to get the request headers and query string parameters just right, and we're not too entirely sure if the <code>session_id</code> acts as an access token such that each one is uniquely generated to prevent this type of malicious request/score modification. Right, so now we know how the game is communicating with the servers and that it may be using some kind of key to prevent bad or unauthorized requests. This means we need to work with the request that the game generates naturally. How, then, do we stop the <em>original</em> request, modify it, and send it along again?</p>\n<h4 id=\"morenetworking\">More Networking</h4>\n<p>The answer to the previous question can be discovered with a simple Google search for &quot;http modify request&quot;. One of these tools is called TamperChrome, and is an add-on/app for Chrome that lets users approve, modify, or decline requests as they are received. In other words, if the game had a phone and dialed Facebook to let them know the score a user received, TamperChrome acts as a redirected circuit on that phone line—it takes the data that was supposed to go directly to the server, modifies it, and sends it along as if nothing ever happened to it. Facebook's servers gladly accept this score as legitimate because everything else about the request is intact, including whatever unique key may have been generated. Running TamperChrome, we modify our score from a pathetic 11 points to an impressive 4011 points and approve this request to be sent along to the server.</p>\n<p><img src=\"/content/images/2017/06/network-score-change.jpg\" alt=\"\"></p>\n<p><img src=\"/content/images/2017/06/network-score-change2.jpg\" alt=\"\"></p>\n<p>The changes are immediate: I've been catapulted to the top of the leaderboards:</p>\n<p><img src=\"/content/images/2017/06/network-score-change3-new.jpg\" alt=\"\"></p>\n<p>Remember: with great power comes great responsibility. Please use this hack with that in mind.</p>\n","comment_id":"2","plaintext":"Facebook recently introduced a whole new range of Instant Games\n[https://messenger.fb.com/blog/instant-games-now-on-messenger/]  that can be\nplayed in their Messenger app, whether on your mobile device or on your desktop.\n\nIntroduction\nNaturally, the ubiquitous introduction of these mini-games have caused every one\nof my group chats on Messenger to become filled with friends savagely competing\nfor the best scores. The more popular of these games include Endless Lake  and \nTrack and Field 100M. The purpose of Endless Lake  is to avoid gaps in the path\nthat your character takes by single and double tapping in order for your sprite\nto jump, whereas Track and Field 100M  challenges you to make your track star\nfinish the race as fast as possible by quickly tapping the screen in succession.\n\nThe problem\nThe problem is simple: how do we get to the top of the scoreboard without\nlegitimately playing the game? In other words, how can we hack and exploit the\nway these games communicate with the Facebook servers that keep track and tally\nthe scores of each player?\n\nThe other problem\nThere's a moral dilemma in hacking anything. On one hand, you're essentially\nsaving yourself a butt-load of time and stress by simply gaming the system,\nplatform, protocol, what-have-you, and finding alternative methods of achieving\nwhat many people believe to be success. On the other hand, you have officially\nbecome the asshole of the group chat for doing this because it's entirely not\nfair for the legitimate players who actually do try very hard to get on the\nleaderboard. I try my hardest not to be that asshole but sometimes having fun\nshould not turn into a debate of morality. Try your best not to lose friends in\nthe heat of the moment, and all should be fine. Onwards!\n\nNetworking\nThe first task is to find out exactly how the game conveys the end score to\nFacebook's servers. This is easily accomplished using Chrome's network\ndeveloper\ntool\n[https://developers.google.com/web/tools/chrome-devtools/network-performance/resource-loading]\n. From here, we're able to observe, filter, and record any and all network\nactivity, including requests, flowing to and from your browser. We clear all\nnetwork activity before we start up one of our games and set it to record\nimmediately before the final score is sent to their servers (either upon your\ncharacter's death or the finish of the race, respectively). The results are as\nfollows:\n\n\n\nFrom this one recorded session, there were 109 requests made. Most of these were\nfor images (.png, .jpeg) files which contained thumbnails of other games and\nFacebook friends. However, the name of the .xhr files starting with \"?doc_id\"\nand \"graphqlbatch\" are of interest, as these are the only plausible ways that\nthe servers could be receiving some kind of data (.xhr is short for\nXMLHttpRequest, which is an API used by a variety of languages used to transfer\nand modify XML data using HTTP between client and server). Looking at the\npreview of the first .xhr file, we see something promising: payload data.\n\n\n\nThis payload holds all the information regarding a player, their current score,\ntheir leaderboard, their friend's leaderboards, etc. This is most likely the\ndata that we're trying to manipulate before it's sent to the server for\nvalidation and insertion. Just to be sure, we take a look at the headers of this\nrequest.\n\n\n\nWe run the request URL through a generic URL decoder, and separate out the\nparameters given in order to get the following data:\n\ndoc_id=903271543141302  \nvariables={\"data\":{  \n    \"client_mutation_id\":\"0\",\n    \"actor_id\":\"100000189902487\",\n    \"game_id\":\"611307059053310\",\n    \"score\":11,\n    \"thread_id\":\"100000189902487\",\n    \"story_id\":null,\n    \"group_id\":null,\n    \"send_admin\":false,\n    \"session_id\":\"cf45dd18-0e1b-4bd8-b388-62913bdf75b3\"\n}}\ndpr=1  \n\n\nNow it's quite clear to see that this request is indeed sending information\nabout the exact game, score, group chat, and other key pieces of data to their\nendpoint at https://www.messenger.com/webgraphql/mutation/. Of course, one might\nthink to simply make a copy of this request and send it along, with just a\nslight modification to the variable score. But this requires too much work; we'd\nhave to get the request headers and query string parameters just right, and\nwe're not too entirely sure if the session_id  acts as an access token such that\neach one is uniquely generated to prevent this type of malicious request/score\nmodification. Right, so now we know how the game is communicating with the\nservers and that it may be using some kind of key to prevent bad or unauthorized\nrequests. This means we need to work with the request that the game generates\nnaturally. How, then, do we stop the original  request, modify it, and send it\nalong again?\n\nMore Networking\nThe answer to the previous question can be discovered with a simple Google\nsearch for \"http modify request\". One of these tools is called TamperChrome, and\nis an add-on/app for Chrome that lets users approve, modify, or decline requests\nas they are received. In other words, if the game had a phone and dialed\nFacebook to let them know the score a user received, TamperChrome acts as a\nredirected circuit on that phone line—it takes the data that was supposed to go\ndirectly to the server, modifies it, and sends it along as if nothing ever\nhappened to it. Facebook's servers gladly accept this score as legitimate\nbecause everything else about the request is intact, including whatever unique\nkey may have been generated. Running TamperChrome, we modify our score from a\npathetic 11 points to an impressive 4011 points and approve this request to be\nsent along to the server.\n\n\n\n\n\nThe changes are immediate: I've been catapulted to the top of the leaderboards:\n\n\n\nRemember: with great power comes great responsibility. Please use this hack with\nthat in mind.","feature_image":"/content/images/2017/06/gift.png","featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":"Hacking Facebook Instant Games with Requests","meta_description":"Modifying requests to hack Facebook's new Messenger games and changing your scores on the leaderboards.","author_id":"1","created_at":"2017-06-08T18:34:00.000Z","created_by":"1","updated_at":"2019-02-07T05:05:58.000Z","updated_by":"1","published_at":"2016-12-07T19:31:00.000Z","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5be78bb59686370eba85dc51","uuid":"9d2b218c-0297-47e7-bbb2-dbe3e4605287","title":"Faster Selenium Tests by Profiling","slug":"faster-selenium-tests-by-profiling","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"Selenium has always been one of the most popular and robust ways to automate browser-based work and testing. There are a variety of methods used for element selection when using the Selenium WebDriver.\\n\\n####Product Parsing\\nConsider the following snippet that creates an instance of Chrome and browses to the Amazon front page and gathers every link it can find:\\n\\n```python\\n# filename: profiler_test.py\\nfrom selenium import webdriver\\n\\nCHROME_DRIVER_PATH = 'chromedriver.exe'\\n\\n\\ndef main():  \\n    d = webdriver.Chrome()\\n\\n    d.get(\\\"https://www.amazon.com\\\")\\n    d.maximize_window()\\n    get_all_pages_links(d)\\n    d.quit()\\n\\n\\ndef get_all_pages_links(d):  \\n    hrefs = []\\n    links = d.find_elements_by_tag_name('a')\\n    for link in links:\\n        href = link.get_attribute('href')\\n        hrefs.append(href)\\n    return hrefs\\n\\n\\nif __name__ == '__main__':  \\n    main()\\n```\\n\\nThis is the page we are seeing by the way:\\n\\n![](/content/images/2017/06/amazon.jpg)\\n\\n####Line Profiling\\nNow the question is, how long did it take us to get the `href` for every `a` tag present on this page? If you're curious, there were 428 total links present on this page alone. That is a lot of searching for Selenium's `find_elements_by_tag_name()` to do. One way to determine how fast our code is running is by using something called a [line profiler](https://www.huyng.com/posts/python-performance-analysis). We add a `@profile` decorator to both `main()` and `get_all_pages_links()` before running our profiler. Via the command line, we run the test with the command `kernprof.exe -l -v profiler_test.py`. Testing this with a profiler, the results are:\\n\\n```bash\\nWrote profile results to profiler_test.py.lprof  \\nTimer unit: 4.26667e-07 s\\n\\nTotal time: 15.8145 s  \\nFile: profiler_test.py  \\nFunction: main at line 8\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n     8                                           @profile\\n     9                                           def main():\\n    10         1      8780838 8780838.0     23.7      d = webdriver.Chrome()\\n    11\\n    12         1      2672345 2672345.0      7.2      d.get(\\\"https://www.amazon.com\\\")\\n    13         1      2871840 2871840.0      7.7      d.maximize_window()\\n    14         1     15225302 15225302.0     41.1      get_all_pages_links(d)\\n    15         1      7514945 7514945.0     20.3      d.quit()\\n\\nTotal time: 6.49449 s  \\nFile: profiler_test.py  \\nFunction: get_all_pages_links at line 18\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n    18                                           @profile\\n    19                                           def get_all_pages_links(d):\\n    20         1            3      3.0      0.0      hrefs = []\\n    21         1      3620538 3620538.0     23.8      links = d.find_elements_by_tag_name('a')\\n    22       428         1198      2.8      0.0      for link in links:\\n    23       427     11595822  27156.5     76.2          href = link.get_attribute('href')\\n    24       427         3875      9.1      0.0          hrefs.append(href)\\n    25         1            1      1.0      0.0      return hrefs\\n```\\n\\nWe see that it took nearly 15.8 seconds for the Chrome instance to start, to navigate to the Amazon page, to gather all links, and then to quit. What was the longest part of this runtime? It was line 23, the one where we ask for each a tag's `href`. In fact, this gathering of `href` values account for 76% of our runtime within the `get_all_pages_links()` function (about 4.94 seconds or more than one-fourth of the total script runtime). This is far too long in terms of automatic web testing. Imagine you needed to gather all links from hundreds and thousands of web pages? The process would take hours for even simple websites.\\n\\n####Utilizing XPath\\nHow can we do better? What other functions can we call from our webdriver.Chrome class such that we can make finding tags and their attributes faster? What if we tried to find all the a tags and their hrefs using XPath? Let's try it. Our code now looks like:\\n\\n```python\\n# filename: profiler_test.py\\n\\nfrom selenium import webdriver\\n\\nCHROME_DRIVER_PATH = 'chromedriver.exe'\\n\\n\\n@profile\\ndef main():  \\n    d = webdriver.Chrome()\\n\\n    d.get(\\\"https://www.amazon.com\\\")\\n    d.maximize_window()\\n    get_all_pages_links(d)\\n    d.quit()\\n\\n\\n@profile\\ndef get_all_pages_links(d):  \\n    hrefs = []\\n    links = d.find_elements_by_xpath('//a')\\n    for link in links:\\n        href = link.get_attribute('href')\\n        hrefs.append(href)\\n    return hrefs\\n\\n\\nif __name__ == '__main__':  \\n    main()\\n```\\n\\nAnd the results from running with the profiler:\\n\\n```bash\\nWrote profile results to profiler_test.py.lprof  \\nTimer unit: 4.26667e-07 s\\n\\nTotal time: 16.262 s  \\nFile: profiler_test.py  \\nFunction: main at line 8\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n     8                                           @profile\\n     9                                           def main():\\n    10         1      8203882 8203882.0     21.5      d = webdriver.Chrome()\\n    11\\n    12         1      8535178 8535178.0     22.4      d.get(\\\"https://www.amazon.com\\\")\\n    13         1      2910691 2910691.0      7.6      d.maximize_window()\\n    14         1     10979849 10979849.0     28.8      get_all_pages_links(d)\\n    15         1      7484319 7484319.0     19.6      d.quit()\\n\\nTotal time: 4.68298 s  \\nFile: profiler_test.py  \\nFunction: get_all_pages_links at line 18\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n    18                                           @profile\\n    19                                           def get_all_pages_links(d):\\n    20         1            3      3.0      0.0      hrefs = []\\n    21         1       317767 317767.0      2.9      links = d.find_elements_by_xpath('//a')\\n    22       431         1092      2.5      0.0      for link in links:\\n    23       430     10652981  24774.4     97.1          href = link.get_attribute('href')\\n    24       430         3875      9.0      0.0          hrefs.append(href)\\n    25         1            2      2.0      0.0      return hrefs\\n```\\n\\nThe same gathering operation now takes around 4.5 seconds. This is an improvement of about half a second. Although good, this is not helpful in the bigger picture. We need these links, and we need them fast. So here's one last idea.\\n\\n####Scripts Within Scripts\\nSelenium WebDrivers have a function called `execute_script()`, which as the name implies injects (JavaScript) code into the browser and returns whatever result that the code does. How about we check to see if directly injecting such a code is faster at getting all the page's links when compared to using `get_attribute()`? The raw JavaScript code to retrieve all page `href` values is coded as such:\\n\\n```javascript\\nfunction get_all_hrefs() {  \\n    var anchors = document.links;\\n    var hrefs = [];\\n    for (var i=0; i<anchors .length; i++) {\\n        hrefs.push(anchors[i].href);\\n    }\\n\\n    return hrefs;\\n}\\n```\\n\\nWe re-write `profiler_test.py` to use this function:\\n\\n```python\\n# filename: profiler_test.py\\n\\nfrom selenium import webdriver\\n\\nCHROME_DRIVER_PATH = 'chromedriver.exe'\\n\\nJS_GET_ALL_HREFS = r'''function get_all_hrefs() {  \\n    var anchors = document.links;\\n    var hrefs = [];\\n    for (var i=0; i<anchors .length; i++) {\\n        hrefs.push(anchors[i].href);\\n    }\\n\\n    return hrefs;\\n}\\nreturn get_all_hrefs();  \\n'''\\n\\n@profile\\ndef main():  \\n    d = webdriver.Chrome()\\n\\n    d.get(\\\"https://www.amazon.com\\\")\\n    d.maximize_window()\\n    get_all_pages_links(d)\\n    d.quit()\\n\\n\\n@profile\\ndef get_all_pages_links(d):  \\n    hrefs = d.execute_script(JS_GET_ALL_HREFS)\\n    return hrefs\\n\\n\\nif __name__ == '__main__':  \\n    main()\\n```\\n\\nAnd lastly, we test with the line profiler:\\n\\n```bash\\nWrote profile results to profiler_test.py.lprof  \\nTimer unit: 4.26667e-07 s\\n\\nTotal time: 10.4917 s  \\nFile: profiler_test.py  \\nFunction: main at line 19\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n    19                                           @profile\\n    20                                           def main():\\n    21         1      8136920 8136920.0     33.1      d = webdriver.Chrome()\\n    22\\n    23         1      5377998 5377998.0     21.9      d.get(\\\"https://www.amazon.com\\\")\\n    24         1      2888695 2888695.0     11.7      d.maximize_window()\\n    25         1       203765 203765.0      0.8      H = get_all_pages_links(d)\\n    26       451         4658     10.3      0.0      for h in H:\\n    27       450       489150   1087.0      2.0          print(h)\\n    28         1      7488800 7488800.0     30.5      d.quit()\\n\\nTotal time: 0.0868468 s  \\nFile: profiler_test.py  \\nFunction: get_all_pages_links at line 31\\n\\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \\n==============================================================\\n    31                                           @profile\\n    32                                           def get_all_pages_links(d):\\n    33         1       203523 203523.0    100.0      hrefs = d.execute_script(JS_GET_ALL_HREFS)\\n    34         1           24     24.0      0.0      return hrefs\\n```\\n\\nThe results speak for themselves. The runtime of `get_all_pages_links()` went from 6.49 seconds to 4.68 seconds to **0.086 seconds**. We improved the time needed to scrape all the page's links by a **factor of more than 75**. These results demonstrate the power of line profiling and how it can be used to drastically improve runtimes. Testing each type of function in a case by case basis lets developers know exactly which ones will run most efficiently so that they can create faster and more robust automated tests. In this case, the links were able to scraped in an alternative way such that we had to go through one less layer of abstraction. Instead of using the Selenium library within Python to access browser elements, we use JavaScript to access those elements much more quickly, and then simply send the results back to our library for processing. By cutting out the middleman, we save time and computational power.\"}]],\"markups\":[],\"sections\":[[10,0]]}","html":"<p>Selenium has always been one of the most popular and robust ways to automate browser-based work and testing. There are a variety of methods used for element selection when using the Selenium WebDriver.</p>\n<h4 id=\"productparsing\">Product Parsing</h4>\n<p>Consider the following snippet that creates an instance of Chrome and browses to the Amazon front page and gathers every link it can find:</p>\n<pre><code class=\"language-python\"># filename: profiler_test.py\nfrom selenium import webdriver\n\nCHROME_DRIVER_PATH = 'chromedriver.exe'\n\n\ndef main():  \n    d = webdriver.Chrome()\n\n    d.get(&quot;https://www.amazon.com&quot;)\n    d.maximize_window()\n    get_all_pages_links(d)\n    d.quit()\n\n\ndef get_all_pages_links(d):  \n    hrefs = []\n    links = d.find_elements_by_tag_name('a')\n    for link in links:\n        href = link.get_attribute('href')\n        hrefs.append(href)\n    return hrefs\n\n\nif __name__ == '__main__':  \n    main()\n</code></pre>\n<p>This is the page we are seeing by the way:</p>\n<p><img src=\"/content/images/2017/06/amazon.jpg\" alt=\"\"></p>\n<h4 id=\"lineprofiling\">Line Profiling</h4>\n<p>Now the question is, how long did it take us to get the <code>href</code> for every <code>a</code> tag present on this page? If you're curious, there were 428 total links present on this page alone. That is a lot of searching for Selenium's <code>find_elements_by_tag_name()</code> to do. One way to determine how fast our code is running is by using something called a <a href=\"https://www.huyng.com/posts/python-performance-analysis\">line profiler</a>. We add a <code>@profile</code> decorator to both <code>main()</code> and <code>get_all_pages_links()</code> before running our profiler. Via the command line, we run the test with the command <code>kernprof.exe -l -v profiler_test.py</code>. Testing this with a profiler, the results are:</p>\n<pre><code class=\"language-bash\">Wrote profile results to profiler_test.py.lprof  \nTimer unit: 4.26667e-07 s\n\nTotal time: 15.8145 s  \nFile: profiler_test.py  \nFunction: main at line 8\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \n==============================================================\n     8                                           @profile\n     9                                           def main():\n    10         1      8780838 8780838.0     23.7      d = webdriver.Chrome()\n    11\n    12         1      2672345 2672345.0      7.2      d.get(&quot;https://www.amazon.com&quot;)\n    13         1      2871840 2871840.0      7.7      d.maximize_window()\n    14         1     15225302 15225302.0     41.1      get_all_pages_links(d)\n    15         1      7514945 7514945.0     20.3      d.quit()\n\nTotal time: 6.49449 s  \nFile: profiler_test.py  \nFunction: get_all_pages_links at line 18\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \n==============================================================\n    18                                           @profile\n    19                                           def get_all_pages_links(d):\n    20         1            3      3.0      0.0      hrefs = []\n    21         1      3620538 3620538.0     23.8      links = d.find_elements_by_tag_name('a')\n    22       428         1198      2.8      0.0      for link in links:\n    23       427     11595822  27156.5     76.2          href = link.get_attribute('href')\n    24       427         3875      9.1      0.0          hrefs.append(href)\n    25         1            1      1.0      0.0      return hrefs\n</code></pre>\n<p>We see that it took nearly 15.8 seconds for the Chrome instance to start, to navigate to the Amazon page, to gather all links, and then to quit. What was the longest part of this runtime? It was line 23, the one where we ask for each a tag's <code>href</code>. In fact, this gathering of <code>href</code> values account for 76% of our runtime within the <code>get_all_pages_links()</code> function (about 4.94 seconds or more than one-fourth of the total script runtime). This is far too long in terms of automatic web testing. Imagine you needed to gather all links from hundreds and thousands of web pages? The process would take hours for even simple websites.</p>\n<h4 id=\"utilizingxpath\">Utilizing XPath</h4>\n<p>How can we do better? What other functions can we call from our webdriver.Chrome class such that we can make finding tags and their attributes faster? What if we tried to find all the a tags and their hrefs using XPath? Let's try it. Our code now looks like:</p>\n<pre><code class=\"language-python\"># filename: profiler_test.py\n\nfrom selenium import webdriver\n\nCHROME_DRIVER_PATH = 'chromedriver.exe'\n\n\n@profile\ndef main():  \n    d = webdriver.Chrome()\n\n    d.get(&quot;https://www.amazon.com&quot;)\n    d.maximize_window()\n    get_all_pages_links(d)\n    d.quit()\n\n\n@profile\ndef get_all_pages_links(d):  \n    hrefs = []\n    links = d.find_elements_by_xpath('//a')\n    for link in links:\n        href = link.get_attribute('href')\n        hrefs.append(href)\n    return hrefs\n\n\nif __name__ == '__main__':  \n    main()\n</code></pre>\n<p>And the results from running with the profiler:</p>\n<pre><code class=\"language-bash\">Wrote profile results to profiler_test.py.lprof  \nTimer unit: 4.26667e-07 s\n\nTotal time: 16.262 s  \nFile: profiler_test.py  \nFunction: main at line 8\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \n==============================================================\n     8                                           @profile\n     9                                           def main():\n    10         1      8203882 8203882.0     21.5      d = webdriver.Chrome()\n    11\n    12         1      8535178 8535178.0     22.4      d.get(&quot;https://www.amazon.com&quot;)\n    13         1      2910691 2910691.0      7.6      d.maximize_window()\n    14         1     10979849 10979849.0     28.8      get_all_pages_links(d)\n    15         1      7484319 7484319.0     19.6      d.quit()\n\nTotal time: 4.68298 s  \nFile: profiler_test.py  \nFunction: get_all_pages_links at line 18\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \n==============================================================\n    18                                           @profile\n    19                                           def get_all_pages_links(d):\n    20         1            3      3.0      0.0      hrefs = []\n    21         1       317767 317767.0      2.9      links = d.find_elements_by_xpath('//a')\n    22       431         1092      2.5      0.0      for link in links:\n    23       430     10652981  24774.4     97.1          href = link.get_attribute('href')\n    24       430         3875      9.0      0.0          hrefs.append(href)\n    25         1            2      2.0      0.0      return hrefs\n</code></pre>\n<p>The same gathering operation now takes around 4.5 seconds. This is an improvement of about half a second. Although good, this is not helpful in the bigger picture. We need these links, and we need them fast. So here's one last idea.</p>\n<h4 id=\"scriptswithinscripts\">Scripts Within Scripts</h4>\n<p>Selenium WebDrivers have a function called <code>execute_script()</code>, which as the name implies injects (JavaScript) code into the browser and returns whatever result that the code does. How about we check to see if directly injecting such a code is faster at getting all the page's links when compared to using <code>get_attribute()</code>? The raw JavaScript code to retrieve all page <code>href</code> values is coded as such:</p>\n<pre><code class=\"language-javascript\">function get_all_hrefs() {  \n    var anchors = document.links;\n    var hrefs = [];\n    for (var i=0; i&lt;anchors .length; i++) {\n        hrefs.push(anchors[i].href);\n    }\n\n    return hrefs;\n}\n</code></pre>\n<p>We re-write <code>profiler_test.py</code> to use this function:</p>\n<pre><code class=\"language-python\"># filename: profiler_test.py\n\nfrom selenium import webdriver\n\nCHROME_DRIVER_PATH = 'chromedriver.exe'\n\nJS_GET_ALL_HREFS = r'''function get_all_hrefs() {  \n    var anchors = document.links;\n    var hrefs = [];\n    for (var i=0; i&lt;anchors .length; i++) {\n        hrefs.push(anchors[i].href);\n    }\n\n    return hrefs;\n}\nreturn get_all_hrefs();  \n'''\n\n@profile\ndef main():  \n    d = webdriver.Chrome()\n\n    d.get(&quot;https://www.amazon.com&quot;)\n    d.maximize_window()\n    get_all_pages_links(d)\n    d.quit()\n\n\n@profile\ndef get_all_pages_links(d):  \n    hrefs = d.execute_script(JS_GET_ALL_HREFS)\n    return hrefs\n\n\nif __name__ == '__main__':  \n    main()\n</code></pre>\n<p>And lastly, we test with the line profiler:</p>\n<pre><code class=\"language-bash\">Wrote profile results to profiler_test.py.lprof  \nTimer unit: 4.26667e-07 s\n\nTotal time: 10.4917 s  \nFile: profiler_test.py  \nFunction: main at line 19\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \n==============================================================\n    19                                           @profile\n    20                                           def main():\n    21         1      8136920 8136920.0     33.1      d = webdriver.Chrome()\n    22\n    23         1      5377998 5377998.0     21.9      d.get(&quot;https://www.amazon.com&quot;)\n    24         1      2888695 2888695.0     11.7      d.maximize_window()\n    25         1       203765 203765.0      0.8      H = get_all_pages_links(d)\n    26       451         4658     10.3      0.0      for h in H:\n    27       450       489150   1087.0      2.0          print(h)\n    28         1      7488800 7488800.0     30.5      d.quit()\n\nTotal time: 0.0868468 s  \nFile: profiler_test.py  \nFunction: get_all_pages_links at line 31\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \n==============================================================\n    31                                           @profile\n    32                                           def get_all_pages_links(d):\n    33         1       203523 203523.0    100.0      hrefs = d.execute_script(JS_GET_ALL_HREFS)\n    34         1           24     24.0      0.0      return hrefs\n</code></pre>\n<p>The results speak for themselves. The runtime of <code>get_all_pages_links()</code> went from 6.49 seconds to 4.68 seconds to <strong>0.086 seconds</strong>. We improved the time needed to scrape all the page's links by a <strong>factor of more than 75</strong>. These results demonstrate the power of line profiling and how it can be used to drastically improve runtimes. Testing each type of function in a case by case basis lets developers know exactly which ones will run most efficiently so that they can create faster and more robust automated tests. In this case, the links were able to scraped in an alternative way such that we had to go through one less layer of abstraction. Instead of using the Selenium library within Python to access browser elements, we use JavaScript to access those elements much more quickly, and then simply send the results back to our library for processing. By cutting out the middleman, we save time and computational power.</p>\n","comment_id":"3","plaintext":"Selenium has always been one of the most popular and robust ways to automate\nbrowser-based work and testing. There are a variety of methods used for element\nselection when using the Selenium WebDriver.\n\nProduct Parsing\nConsider the following snippet that creates an instance of Chrome and browses to\nthe Amazon front page and gathers every link it can find:\n\n# filename: profiler_test.py\nfrom selenium import webdriver\n\nCHROME_DRIVER_PATH = 'chromedriver.exe'\n\n\ndef main():  \n    d = webdriver.Chrome()\n\n    d.get(\"https://www.amazon.com\")\n    d.maximize_window()\n    get_all_pages_links(d)\n    d.quit()\n\n\ndef get_all_pages_links(d):  \n    hrefs = []\n    links = d.find_elements_by_tag_name('a')\n    for link in links:\n        href = link.get_attribute('href')\n        hrefs.append(href)\n    return hrefs\n\n\nif __name__ == '__main__':  \n    main()\n\n\nThis is the page we are seeing by the way:\n\n\n\nLine Profiling\nNow the question is, how long did it take us to get the href  for every a  tag\npresent on this page? If you're curious, there were 428 total links present on\nthis page alone. That is a lot of searching for Selenium's \nfind_elements_by_tag_name()  to do. One way to determine how fast our code is\nrunning is by using something called a line profiler\n[https://www.huyng.com/posts/python-performance-analysis]. We add a @profile \ndecorator to both main()  and get_all_pages_links()  before running our\nprofiler. Via the command line, we run the test with the command kernprof.exe -l\n-v profiler_test.py. Testing this with a profiler, the results are:\n\nWrote profile results to profiler_test.py.lprof  \nTimer unit: 4.26667e-07 s\n\nTotal time: 15.8145 s  \nFile: profiler_test.py  \nFunction: main at line 8\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \n==============================================================\n     8                                           @profile\n     9                                           def main():\n    10         1      8780838 8780838.0     23.7      d = webdriver.Chrome()\n    11\n    12         1      2672345 2672345.0      7.2      d.get(\"https://www.amazon.com\")\n    13         1      2871840 2871840.0      7.7      d.maximize_window()\n    14         1     15225302 15225302.0     41.1      get_all_pages_links(d)\n    15         1      7514945 7514945.0     20.3      d.quit()\n\nTotal time: 6.49449 s  \nFile: profiler_test.py  \nFunction: get_all_pages_links at line 18\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \n==============================================================\n    18                                           @profile\n    19                                           def get_all_pages_links(d):\n    20         1            3      3.0      0.0      hrefs = []\n    21         1      3620538 3620538.0     23.8      links = d.find_elements_by_tag_name('a')\n    22       428         1198      2.8      0.0      for link in links:\n    23       427     11595822  27156.5     76.2          href = link.get_attribute('href')\n    24       427         3875      9.1      0.0          hrefs.append(href)\n    25         1            1      1.0      0.0      return hrefs\n\n\nWe see that it took nearly 15.8 seconds for the Chrome instance to start, to\nnavigate to the Amazon page, to gather all links, and then to quit. What was the\nlongest part of this runtime? It was line 23, the one where we ask for each a\ntag's href. In fact, this gathering of href  values account for 76% of our\nruntime within the get_all_pages_links()  function (about 4.94 seconds or more\nthan one-fourth of the total script runtime). This is far too long in terms of\nautomatic web testing. Imagine you needed to gather all links from hundreds and\nthousands of web pages? The process would take hours for even simple websites.\n\nUtilizing XPath\nHow can we do better? What other functions can we call from our webdriver.Chrome\nclass such that we can make finding tags and their attributes faster? What if we\ntried to find all the a tags and their hrefs using XPath? Let's try it. Our code\nnow looks like:\n\n# filename: profiler_test.py\n\nfrom selenium import webdriver\n\nCHROME_DRIVER_PATH = 'chromedriver.exe'\n\n\n@profile\ndef main():  \n    d = webdriver.Chrome()\n\n    d.get(\"https://www.amazon.com\")\n    d.maximize_window()\n    get_all_pages_links(d)\n    d.quit()\n\n\n@profile\ndef get_all_pages_links(d):  \n    hrefs = []\n    links = d.find_elements_by_xpath('//a')\n    for link in links:\n        href = link.get_attribute('href')\n        hrefs.append(href)\n    return hrefs\n\n\nif __name__ == '__main__':  \n    main()\n\n\nAnd the results from running with the profiler:\n\nWrote profile results to profiler_test.py.lprof  \nTimer unit: 4.26667e-07 s\n\nTotal time: 16.262 s  \nFile: profiler_test.py  \nFunction: main at line 8\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \n==============================================================\n     8                                           @profile\n     9                                           def main():\n    10         1      8203882 8203882.0     21.5      d = webdriver.Chrome()\n    11\n    12         1      8535178 8535178.0     22.4      d.get(\"https://www.amazon.com\")\n    13         1      2910691 2910691.0      7.6      d.maximize_window()\n    14         1     10979849 10979849.0     28.8      get_all_pages_links(d)\n    15         1      7484319 7484319.0     19.6      d.quit()\n\nTotal time: 4.68298 s  \nFile: profiler_test.py  \nFunction: get_all_pages_links at line 18\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \n==============================================================\n    18                                           @profile\n    19                                           def get_all_pages_links(d):\n    20         1            3      3.0      0.0      hrefs = []\n    21         1       317767 317767.0      2.9      links = d.find_elements_by_xpath('//a')\n    22       431         1092      2.5      0.0      for link in links:\n    23       430     10652981  24774.4     97.1          href = link.get_attribute('href')\n    24       430         3875      9.0      0.0          hrefs.append(href)\n    25         1            2      2.0      0.0      return hrefs\n\n\nThe same gathering operation now takes around 4.5 seconds. This is an\nimprovement of about half a second. Although good, this is not helpful in the\nbigger picture. We need these links, and we need them fast. So here's one last\nidea.\n\nScripts Within Scripts\nSelenium WebDrivers have a function called execute_script(), which as the name\nimplies injects (JavaScript) code into the browser and returns whatever result\nthat the code does. How about we check to see if directly injecting such a code\nis faster at getting all the page's links when compared to using get_attribute()\n? The raw JavaScript code to retrieve all page href  values is coded as such:\n\nfunction get_all_hrefs() {  \n    var anchors = document.links;\n    var hrefs = [];\n    for (var i=0; i<anchors .length; i++) {\n        hrefs.push(anchors[i].href);\n    }\n\n    return hrefs;\n}\n\n\nWe re-write profiler_test.py  to use this function:\n\n# filename: profiler_test.py\n\nfrom selenium import webdriver\n\nCHROME_DRIVER_PATH = 'chromedriver.exe'\n\nJS_GET_ALL_HREFS = r'''function get_all_hrefs() {  \n    var anchors = document.links;\n    var hrefs = [];\n    for (var i=0; i<anchors .length; i++) {\n        hrefs.push(anchors[i].href);\n    }\n\n    return hrefs;\n}\nreturn get_all_hrefs();  \n'''\n\n@profile\ndef main():  \n    d = webdriver.Chrome()\n\n    d.get(\"https://www.amazon.com\")\n    d.maximize_window()\n    get_all_pages_links(d)\n    d.quit()\n\n\n@profile\ndef get_all_pages_links(d):  \n    hrefs = d.execute_script(JS_GET_ALL_HREFS)\n    return hrefs\n\n\nif __name__ == '__main__':  \n    main()\n\n\nAnd lastly, we test with the line profiler:\n\nWrote profile results to profiler_test.py.lprof  \nTimer unit: 4.26667e-07 s\n\nTotal time: 10.4917 s  \nFile: profiler_test.py  \nFunction: main at line 19\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \n==============================================================\n    19                                           @profile\n    20                                           def main():\n    21         1      8136920 8136920.0     33.1      d = webdriver.Chrome()\n    22\n    23         1      5377998 5377998.0     21.9      d.get(\"https://www.amazon.com\")\n    24         1      2888695 2888695.0     11.7      d.maximize_window()\n    25         1       203765 203765.0      0.8      H = get_all_pages_links(d)\n    26       451         4658     10.3      0.0      for h in H:\n    27       450       489150   1087.0      2.0          print(h)\n    28         1      7488800 7488800.0     30.5      d.quit()\n\nTotal time: 0.0868468 s  \nFile: profiler_test.py  \nFunction: get_all_pages_links at line 31\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents  \n==============================================================\n    31                                           @profile\n    32                                           def get_all_pages_links(d):\n    33         1       203523 203523.0    100.0      hrefs = d.execute_script(JS_GET_ALL_HREFS)\n    34         1           24     24.0      0.0      return hrefs\n\n\nThe results speak for themselves. The runtime of get_all_pages_links()  went\nfrom 6.49 seconds to 4.68 seconds to 0.086 seconds. We improved the time needed\nto scrape all the page's links by a factor of more than 75. These results\ndemonstrate the power of line profiling and how it can be used to drastically\nimprove runtimes. Testing each type of function in a case by case basis lets\ndevelopers know exactly which ones will run most efficiently so that they can\ncreate faster and more robust automated tests. In this case, the links were able\nto scraped in an alternative way such that we had to go through one less layer\nof abstraction. Instead of using the Selenium library within Python to access\nbrowser elements, we use JavaScript to access those elements much more quickly,\nand then simply send the results back to our library for processing. By cutting\nout the middleman, we save time and computational power.","feature_image":"/content/images/2017/06/profiling.png","featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":"Faster Selenium Tests by Profiling","meta_description":"We use Python's line profiler tool to analyze our code, and use the results to conduct faster Selenium tests after identifying bottlenecks in our algorithm.","author_id":"1","created_at":"2017-06-08T18:49:27.000Z","created_by":"1","updated_at":"2019-02-07T05:07:18.000Z","updated_by":"1","published_at":"2017-02-28T22:12:00.000Z","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5c5bbbc35d0d6b08c557fff6","uuid":"46321797-5fbb-4fe8-9a86-a9c23b536ef8","title":"A Waste of Wax","slug":"a-waste-of-wax","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"The problems below were posed by my *Design and Analysis of Algorithms* professor. Although we did not spend much time on the solution or its implications, I figured over-analyzing it might be in order if I wanted to read back on this in the future and think of the productivity wasted on this post.\\n\\n#### The initial problem\\nGiven a special candle of unknown length that burns up in one hour regardless of the orientation it is placed in (i.e. whether the candle is lit upside down or right side up or some other degree of rotation), how can you use this candle as a timer to know when 30 minutes have passed? The density of the candle's wax varies along the whole length, so two equal lengths will burn up in different times (you aren't allowed to measure the length of the candle anyway). Assume the wick is present on both ends of the candle (meaning you can light two fires at once), and that you are able to light a fire or split the candle with no loss of relative time. Remember: you need the timer to start immediately, so the goal is to use the candle as a timer, not to be left with a candle timer. This is a variation of the [burning rope problem](https://curiosity.com/topics/the-burning-rope-logic-puzzle/) but uses the more environmentally conscious alternative to setting ropes on fire: burning candles.\\n\\n#### The initial solution\\nLight both ends of the candle. It is trivial to see how we can measure 30 minutes using a single candle and two fires. Regardless of how long the candle is, we simply need the information that the whole candle will burn in one hour; this means that the amount of wax present is only able to fuel one hour of burn time with one fire going. Thus, burning two fires using both ends of the candle means using the same amount of fuel but twice as fast. Therefore, once the two fires meet and the candle runs out of wax, 30 minutes have passed.\\n\\n#### Blackouts are inconvenient\\nSay you found a stash of more one-hour candles. What if you had the same problem as above, but now wanted to measure 45 minutes? We already know how to achieve 30 minutes using one candle, so going for 45 minutes with two candles should not be a tall order. The solution is as follows: light the two ends of the first candle as above, but also light one end of a second candle. Once the first candle burns out in 30 minutes, we are left with 30 minutes remaining on the second burning candle. Light the unlit end in order to get this candle to use fuel twice as fast, so that it burns out in 15 minutes. This gives us 45 minutes of total light we wanted.\\n\\nWhat happens if we wanted to get 15 minutes using only one candle? Turns out, this is the hardest of the problems encountered so far. Since we only have one candle, it'd be impossible to get any amount of time less than 30 minutes without having to split the candle into two or more parts. Thus, the solution lies in breaking this one candle into two pieces of candle. The non-intuitive part of it all is that the length of the two pieces do not matter in this solution. In fact, length does not play a role in finding the solution to any amount of time, which is why the seemingly unknown length is irrelevant to the whole thing. We now have two (unequal) child parts of the same candle. The first step of the solution is to light both ends of both candles, so that there are 4 fires burning at the same time. You can sort of see a pattern now: one fire equals an hour of light, two fires give half that time, etc. The caveat to burning four fires is knowing what to do after the first of the two pairs of fires burn out earlier than the other (which it will, as the two unequal pieces imply that one has to be shorter). The solution is simple: the moment the first child candle burns out, take the other candle and split it into two child pieces again, and make sure both ends are lit for each. Since we are assuming there is no wasted time in splitting candles and lighting fires, the candles will all eventually burn out completely in 15 minutes. Simply explained, the whole candle will burn out in 15 minutes because you will always have four fires burning simultaneously. This is similar to the 30 minutes solution: at any time, your candle will be burning two fires, so it runs out of fuel twice as fast. In this solution, your candle is running out of fuel 4 times as fast, and therefore your fuel lasts a fourth of an hour. In general, if you had multiple children candles, you split a remaining candle every time one of them burns out in order to maintain the same number of fires alive to consume the total fuel.\\n\\nThe table below shows the general pattern of parts and fires needed to achieve a given burning time in minutes for one candle. Parts, in this case, means the number of parts you are splitting the initial candle into, and does not account for the times you recursively break up the child candles.\\n\\n<table>\\n  <tr>\\n    <th>Parts</th>\\n    <th>Fires</th> \\n    <th>Time</th>\\n  </tr>\\n  <tr>\\n    <td>1</td>\\n    <td>1</td> \\n    <td>60</td>\\n  </tr>\\n  <tr>\\n    <td>1</td>\\n    <td>2</td> \\n    <td>30</td>\\n  </tr>\\n  <tr>\\n    <td>2</td>\\n    <td>3</td> \\n    <td>20</td>\\n  </tr>\\n  <tr>\\n    <td>2</td>\\n    <td>4</td> \\n    <td>15</td>\\n  </tr>\\n  <tr>\\n    <td>3</td>\\n    <td>5</td> \\n    <td>12</td>\\n  </tr>\\n  <tr>\\n    <td>3</td>\\n    <td>6</td> \\n    <td>10</td>\\n  </tr>\\n</table>\\n\\n#### What time is it?\\nThe general equation for the number of fires $f$ needed to achieve a time $t$ in minutes is then simply $f=\\\\frac{60}t$. The number of parts $p$ needed given $f$ is then $p=\\\\lceil\\\\frac{f}2 \\\\rceil$. Keep in mind that this equation is valid only if we have one candle, and therefore $f\\\\in\\\\mathbb{Z^+}$. If such is the case, then the only exact times we are able to achieve with one candle are the quotients of dividing 60 by any positive integer. We can say that given a candle that normally burns (with a single flame) in $m$ minutes, the set of all solutions are in $\\\\\\\\{\\\\frac mz \\\\mid z\\\\in\\\\mathbb{Z^+}\\\\\\\\}$. So, knowing how the solution plays out, and how long one candle burns for, let's write a simple Python script to calculate how many parts the initial candle needs to be split into, and how many fires need to be simultaneously lit in order to achieve a desired time. We have two arguments to pass in: `burn_rate` (the time it takes to burn the whole candle with a single fire) and `target_time` (a time you'd like to waste playing with candles). The program should output a tuple: the former number will be the parts to split into and the latter will be the number of fires to light between all those parts. These two pieces of information will get you as close to your `target_time` as possible without exceeding it. The code below demonstrates one way of achieving this.\\n\\n```language-python\\nimport math\\n\\ndef candle_waster(burn_rate, target_time):\\n  fires = math.ceil(burn_rate/target_time)\\n  parts = math.ceil(fires/2)\\n  if target_time > burn_rate:\\n    return \\\"Can't burn candle longer than burn_rate\\\"\\n  return parts, fires\\n    \\nprint(candle_waster(60,15))\\nprint(candle_waster(30,5))\\nprint(candle_waster(10,1))\\nprint(candle_waster(5,3))\\nprint(candle_waster(1,2))\\n```\\n```language-none\\n(2, 4)\\n(3, 6)\\n(5, 10)\\n(1, 2)\\nCan't burn candle longer than burn_rate\\n```\\nThat was the easier part. Let's figure out what times we're able to achieve with more than one candle.\\n\\n#### Lots and lots of wax\\n\\nSuppose now we have two candles that all have the same burn rate of $m$ minutes each. It is simple to see that we are able to achieve a maximum time of $2m$ minutes by using them in succession&mdash;that is, burning them one by one until we're done. In fact, these \\\"additive\\\" times are reached simply by adding any times $t\\\\_1$ and $t\\\\_2$ together such that $t\\\\_1, t\\\\_2 \\\\in S$, where $S = \\\\\\\\{\\\\frac mz \\\\mid z\\\\in\\\\mathbb{Z^+}\\\\\\\\}$ (the set of times possible with each candle of burn rate $m$). One can see that $\\\\lvert S \\\\rvert = \\\\infty$ because we haven't defined proper constraints for $z$. For our sake, we can define a maximum number of fires $e$ allowed for each candle (meaning no one candle can have more than $e$ fires ablaze at one time, which limits the magnitude of $S$ to a finite number). Furthermore, let's define $S\\\\_{m,e}$ to mean **the set of times achievable with a single candle of burn rate $m$ and max fires of $e$**:\\n$$\\nS\\\\_{m,e} = \\\\\\\\{\\\\frac mz \\\\mid z\\\\in\\\\mathbb{Z^+}, 1 \\\\leq z \\\\leq e \\\\\\\\}\\n$$\\nAs an example, set $m=60, e=3$. Thus, the two candles are able to produce the times in $S\\\\_{60,3}$ *individually*. This means that, by itself, any one of the two candles can produce any of these times in the set $S\\\\_{60,3} = \\\\\\\\{60,30,20\\\\\\\\}$. Utilizing both of them, however, produces a wider range of possible times.\\n\\n---\\n\\nThe set of possible times of using *both* candles is expanded because you have more choices as to how you go about lighting, splitting, and delaying each candle. One set of possibilities is the option of successively lighting each candle after the last one burns out. Let's call this set of times $T\\\\_{sc}$. In our example above, each candle is able to burn for either 60, 30, or 20 minutes each. We see that if we burn the first candle for 60 minutes, *then* burn the second for 60 minutes, we've produced a new possible time of 120 minutes. Each of the times in $S\\\\_{60,3}$ is added to all possible times also in the same set $S\\\\_{60,3}$. As such, we are left with $T\\\\_{sc}$ containing the set of numbers which result from the [Minkowski addition](https://en.wikipedia.org/wiki/Minkowski_addition) (or direct sum) of $S\\\\_{60,3}$ and itself. It's intuitive to see how the times form from successive burning, and we demonstrate it below with all possible cases of said process. Let the first and second candles, along with their remaining burn times, be $c\\\\_{1},c\\\\_{2},b\\\\_{1},b\\\\_{2}$, respectively.\\n\\nSuccessive burning:\\n\\n* (Case 1) $c\\\\_{1}$ burns for $b\\\\_{1}=60$ minutes, then\\n    * (1A) $c\\\\_{2}$ burns for $b\\\\_{2}=60$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 120 minutes.\\n    * (1B) $c\\\\_{2}$ burns for $b\\\\_{2}=30$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 90 minutes.\\n    * (1C) $c\\\\_{2}$ burns for $b\\\\_{2}=20$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 80 minutes.\\n\\n* (Case 2) $c\\\\_{1}$ burns for $b\\\\_{1}=30$ minutes, then\\n    * (2A) $c\\\\_{2}$ burns for $b\\\\_{2}=60$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 90 minutes.\\n    * (2B) $c\\\\_{2}$ burns for $b\\\\_{2}=30$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 60 minutes.\\n    * (2C) $c\\\\_{2}$ burns for $b\\\\_{2}=20$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 50 minutes.\\n\\n* (Case 3) $c\\\\_{1}$ burns for $b\\\\_{1}=20$ minutes, then\\n    * (3A) $c\\\\_{2}$ burns for $b\\\\_{2}=60$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 80 minutes.\\n    * (3B) $c\\\\_{2}$ burns for $b\\\\_{2}=30$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 50 minutes.\\n    * (3C) $c\\\\_{2}$ burns for $b\\\\_{2}=20$ minutes $\\\\rightarrow b\\\\_{1}+ b\\\\_{2} =$ 40 minutes.\\n\\nThus, $T\\\\_{sc} = \\\\\\\\{120,90,80,60,50,40\\\\\\\\}$ given two candles, with $m=60, e=3$. The other option of discovering time possibilities is the idea of simultaneously burning the candles. This method is a bit trickier. Recall that towards the start of this post was a solution for 45 minutes that involved two candles: the first candle was lit on one end and the second was lit on both ends. Both burned for 30 minutes (until the second one burned out) and the first one was left with 30 remaining minutes of wax (30 minutes have also passed at this point). We ensured the remaining one had two fires ablaze and thus burned twice as fast with 30 minutes of fuel left, which means it burned for 15 minutes. The 30 minutes from the simultaneous burning and the 15 from the remainder burning produced 45 total minutes. This was possible because we were able to reduce the first candle's burn rate down by any attainable time of the second candle, and from there we solved the sub-problem of getting 15 minutes using an $m=30$ candle. Let $T\\\\_{sim}$ be the set of times that result from simultaneously burning both candles and adding on the time possibility set of the remaining candle. Each case of these simultaneously burnings are outline below.\\n\\nSimultaneous (then remainder) burning:\\n\\n* (Case 1) Light $c\\\\_{1}$ with 1 fire ($b\\\\_{1}=60$) along with\\n    * (1A) $c\\\\_{2}$ with 1 fire ($b\\\\_{2}=60$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=0$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 60+\\\\\\\\{0\\\\\\\\} = \\\\\\\\{60\\\\\\\\}$\\n    * (1B) $c\\\\_{2}$ with 2 fires ($b\\\\_{2}=30$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=30$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 30+\\\\\\\\{30,15,10\\\\\\\\} = \\\\\\\\{60,45,40\\\\\\\\}$\\n    * (1C) $c\\\\_{2}$ with 3 fires ($b\\\\_{2}=20$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=40$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 20+\\\\\\\\{40,20,\\\\frac{40}3\\\\\\\\} = \\\\\\\\{60,40,33\\\\frac13\\\\\\\\}$\\n\\n* (Case 2) Light $c\\\\_{1}$ with 2 fires ($b\\\\_{1}=30$) along with\\n    * (2A) $c\\\\_{2}$ with 1 fire ($b\\\\_{2}=60$) $\\\\rightarrow$ same as case 1B.\\n    * (2B) $c\\\\_{2}$ with 2 fires ($b\\\\_{2}=30$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=0$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 30+\\\\\\\\{0\\\\\\\\} = \\\\\\\\{30\\\\\\\\}$\\n    * (2C) $c\\\\_{2}$ with 3 fires ($b\\\\_{2}=20$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=10$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 20+\\\\\\\\{10,5,\\\\frac{10}3\\\\\\\\} = \\\\\\\\{30,25,23\\\\frac13\\\\\\\\}$\\n\\n* (Case 3) Light $c\\\\_{1}$ with 3 fires ($b\\\\_{1}=20$) along with\\n    * (3A) $c\\\\_{2}$ with 1 fire ($b\\\\_{2}=60$) $\\\\rightarrow$ same as case 1C.\\n    * (3B) $c\\\\_{2}$ with 2 fires ($b\\\\_{2}=30$) $\\\\rightarrow$ same as case 2C.\\n    * (3C) $c\\\\_{2}$ with 3 fires ($b\\\\_{2}=20$) $\\\\rightarrow$ $c\\\\_{2}$ burns out; $b\\\\_{1}=0$ remains.\\n        * $b\\\\_{2} + S\\\\_{b\\\\_{1},e=3} = 20+\\\\\\\\{0\\\\\\\\} = \\\\\\\\{20\\\\\\\\}$\\n\\nThus, $T\\\\_{sim} = \\\\\\\\{60,45,40,33\\\\frac13,30,25,23\\\\frac13,20\\\\\\\\}$ given two candles, with $m=60, e=3$. We have then that given these two candles, we're about to produce the final set of times $T$:\\n$$\\nT = S\\\\_{60,3} \\\\cup T\\\\_{sc} \\\\cup T\\\\_{sim}=\\\\\\\\{120,90,80,60,50,45,40,33\\\\frac13,30,25,23\\\\frac13,20\\\\\\\\}\\n$$\\nNow, what would happen with three candles? The short story is, the successive times of three candles with the same burn rate and max fires is simply the direct sum of our previous times of 2 candles $T$ with another $S\\\\_{60,3}$. Similarly, the possible simultaneous times of this group would utilize the same procedure we used for $S\\\\_{60,3}$, except now we find all possible cases using the expanded set of times $T$ instead. Let's define a few functions back in Python to help us figure out all the times given a number of `candles`, a `burn_rate`, and `max_fires`. The function `times_succession()` accepts two sets and returns the direct sum of those two sets. The function `times_simul()` accepts two sets and max fires, and returns the set of times as described in our simultaneous and remainder burning above. `times_of_one_candle()` simply returns the set of times possible with one candle given its burn rate and max fires.\\n\\n```language-python\\ndef times_succession(set_one, set_two):\\n    t_sc = set([])\\n\\n    for x in set_one:\\n        for y in set_two:\\n            t_sc |= {round(x + y, 4)}\\n\\n    return t_sc\\n\\n\\ndef times_simul(set_one, set_two, max_fires):\\n    t_sim = set([])\\n\\n    for x in set_one:\\n        for y in set_two:\\n            if x >= y:\\n                remaining_time = x - y\\n                t = times_succession({round(y, 4)}, times_of_one_candle(remaining_time, max_fires))\\n                t_sim |= t\\n\\n    return t_sim\\n\\n\\ndef times_of_one_candle(burn_rate, max_fires):\\n    s = set([])\\n\\n    for x in range(1, max_fires + 1):\\n        s |= {burn_rate / x}\\n\\n    return s\\n```\\n\\nWe now have functions that return all the subsets needed for our equation in order to find all the possible sets given the correct parameters. Let's write a function `all_times()`, which takes in our three arguments `candles`, `burn_rate`, and `max_fires` and calls our helper functions to return the set of all times that we are able to achieve with these constraints.\\n\\n```language-python\\ndef all_times(candles, burn_rate, max_fires):\\n    if candles == 0 or burn_rate == 0 or max_fires == 0:\\n        return set([])\\n    if candles == 1:\\n        return times_of_one_candle(burn_rate, max_fires)\\n\\n    times = set([])\\n\\n    s = times_of_one_candle(burn_rate, max_fires)\\n    times |= s\\n\\n    for c in range(1, candles):\\n        t_sc = times_succession(times, s)\\n        t_sim = times_simul(times, s, max_fires)\\n        times |= (t_sc | t_sim)\\n\\n    return times\\n\\ns = sorted(all_times(2, 60, 3), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n    \\ns = sorted(all_times(3, 60, 4), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n    \\ns = sorted(all_times(4, 100, 5), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n    \\ns = sorted(all_times(5, 100, 6), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n    \\ns = sorted(all_times(6, 200, 5), reverse=True)\\nprint('{}\\\\nMagnitude: {}'.format(s, len(s)))\\n```\\n```language-none\\n[120.0, 90.0, 80.0, 60.0, 50.0, 45.0, 40.0, 33.3333, 30.0, 25.0, 23.3333, 20.0]\\nMagnitude: 12\\n[180.0, 150.0, 140.0, 120.0, 110.0, 105.0, 100.0, 93.3333, 90.0, 85.0, 83.3333, ...]\\nMagnitude: 100\\n[400.0, 350.0, 333.3333, 325.0, 300.0, 283.3333, 275.0, 266.6667, 266.6666, ...]\\nMagnitude: 2414\\n[500.0, 450.0, 433.3333, 425.0, 420.0, 400.0, 383.3333, 375.0, 370.0, 366.6667, ...]\\nMagnitude: 30885\\n[1200.0, 1100.0, 1066.6667, 1050.0, 1040.0, 1000.0, 966.6667, 950.0, 940.0, ...]\\nMagnitude: 75430\\n```\\n\\nThe magnitude of each set displayed is simply the number of possible times. At this point, it's trivial to search for a time goal by reversing the process such that the script gives us `candles`, `burn_rate`, and/or `max_fires` given an input time goal.\\n\\nFinally, it is also pretty trivial to imagine how many hours and chances ago I should have stopped trying to dive into this problem, but we both know those attempts were futile.\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]]}","html":"<p>The problems below were posed by my <em>Design and Analysis of Algorithms</em> professor. Although we did not spend much time on the solution or its implications, I figured over-analyzing it might be in order if I wanted to read back on this in the future and think of the productivity wasted on this post.</p>\n<h4 id=\"theinitialproblem\">The initial problem</h4>\n<p>Given a special candle of unknown length that burns up in one hour regardless of the orientation it is placed in (i.e. whether the candle is lit upside down or right side up or some other degree of rotation), how can you use this candle as a timer to know when 30 minutes have passed? The density of the candle's wax varies along the whole length, so two equal lengths will burn up in different times (you aren't allowed to measure the length of the candle anyway). Assume the wick is present on both ends of the candle (meaning you can light two fires at once), and that you are able to light a fire or split the candle with no loss of relative time. Remember: you need the timer to start immediately, so the goal is to use the candle as a timer, not to be left with a candle timer. This is a variation of the <a href=\"https://curiosity.com/topics/the-burning-rope-logic-puzzle/\">burning rope problem</a> but uses the more environmentally conscious alternative to setting ropes on fire: burning candles.</p>\n<h4 id=\"theinitialsolution\">The initial solution</h4>\n<p>Light both ends of the candle. It is trivial to see how we can measure 30 minutes using a single candle and two fires. Regardless of how long the candle is, we simply need the information that the whole candle will burn in one hour; this means that the amount of wax present is only able to fuel one hour of burn time with one fire going. Thus, burning two fires using both ends of the candle means using the same amount of fuel but twice as fast. Therefore, once the two fires meet and the candle runs out of wax, 30 minutes have passed.</p>\n<h4 id=\"blackoutsareinconvenient\">Blackouts are inconvenient</h4>\n<p>Say you found a stash of more one-hour candles. What if you had the same problem as above, but now wanted to measure 45 minutes? We already know how to achieve 30 minutes using one candle, so going for 45 minutes with two candles should not be a tall order. The solution is as follows: light the two ends of the first candle as above, but also light one end of a second candle. Once the first candle burns out in 30 minutes, we are left with 30 minutes remaining on the second burning candle. Light the unlit end in order to get this candle to use fuel twice as fast, so that it burns out in 15 minutes. This gives us 45 minutes of total light we wanted.</p>\n<p>What happens if we wanted to get 15 minutes using only one candle? Turns out, this is the hardest of the problems encountered so far. Since we only have one candle, it'd be impossible to get any amount of time less than 30 minutes without having to split the candle into two or more parts. Thus, the solution lies in breaking this one candle into two pieces of candle. The non-intuitive part of it all is that the length of the two pieces do not matter in this solution. In fact, length does not play a role in finding the solution to any amount of time, which is why the seemingly unknown length is irrelevant to the whole thing. We now have two (unequal) child parts of the same candle. The first step of the solution is to light both ends of both candles, so that there are 4 fires burning at the same time. You can sort of see a pattern now: one fire equals an hour of light, two fires give half that time, etc. The caveat to burning four fires is knowing what to do after the first of the two pairs of fires burn out earlier than the other (which it will, as the two unequal pieces imply that one has to be shorter). The solution is simple: the moment the first child candle burns out, take the other candle and split it into two child pieces again, and make sure both ends are lit for each. Since we are assuming there is no wasted time in splitting candles and lighting fires, the candles will all eventually burn out completely in 15 minutes. Simply explained, the whole candle will burn out in 15 minutes because you will always have four fires burning simultaneously. This is similar to the 30 minutes solution: at any time, your candle will be burning two fires, so it runs out of fuel twice as fast. In this solution, your candle is running out of fuel 4 times as fast, and therefore your fuel lasts a fourth of an hour. In general, if you had multiple children candles, you split a remaining candle every time one of them burns out in order to maintain the same number of fires alive to consume the total fuel.</p>\n<p>The table below shows the general pattern of parts and fires needed to achieve a given burning time in minutes for one candle. Parts, in this case, means the number of parts you are splitting the initial candle into, and does not account for the times you recursively break up the child candles.</p>\n<table>\n  <tr>\n    <th>Parts</th>\n    <th>Fires</th> \n    <th>Time</th>\n  </tr>\n  <tr>\n    <td>1</td>\n    <td>1</td> \n    <td>60</td>\n  </tr>\n  <tr>\n    <td>1</td>\n    <td>2</td> \n    <td>30</td>\n  </tr>\n  <tr>\n    <td>2</td>\n    <td>3</td> \n    <td>20</td>\n  </tr>\n  <tr>\n    <td>2</td>\n    <td>4</td> \n    <td>15</td>\n  </tr>\n  <tr>\n    <td>3</td>\n    <td>5</td> \n    <td>12</td>\n  </tr>\n  <tr>\n    <td>3</td>\n    <td>6</td> \n    <td>10</td>\n  </tr>\n</table>\n<h4 id=\"whattimeisit\">What time is it?</h4>\n<p>The general equation for the number of fires $f$ needed to achieve a time $t$ in minutes is then simply $f=\\frac{60}t$. The number of parts $p$ needed given $f$ is then $p=\\lceil\\frac{f}2 \\rceil$. Keep in mind that this equation is valid only if we have one candle, and therefore $f\\in\\mathbb{Z^+}$. If such is the case, then the only exact times we are able to achieve with one candle are the quotients of dividing 60 by any positive integer. We can say that given a candle that normally burns (with a single flame) in $m$ minutes, the set of all solutions are in $\\{\\frac mz \\mid z\\in\\mathbb{Z^+}\\}$. So, knowing how the solution plays out, and how long one candle burns for, let's write a simple Python script to calculate how many parts the initial candle needs to be split into, and how many fires need to be simultaneously lit in order to achieve a desired time. We have two arguments to pass in: <code>burn_rate</code> (the time it takes to burn the whole candle with a single fire) and <code>target_time</code> (a time you'd like to waste playing with candles). The program should output a tuple: the former number will be the parts to split into and the latter will be the number of fires to light between all those parts. These two pieces of information will get you as close to your <code>target_time</code> as possible without exceeding it. The code below demonstrates one way of achieving this.</p>\n<pre><code class=\"language-language-python\">import math\n\ndef candle_waster(burn_rate, target_time):\n  fires = math.ceil(burn_rate/target_time)\n  parts = math.ceil(fires/2)\n  if target_time &gt; burn_rate:\n    return &quot;Can't burn candle longer than burn_rate&quot;\n  return parts, fires\n    \nprint(candle_waster(60,15))\nprint(candle_waster(30,5))\nprint(candle_waster(10,1))\nprint(candle_waster(5,3))\nprint(candle_waster(1,2))\n</code></pre>\n<pre><code class=\"language-language-none\">(2, 4)\n(3, 6)\n(5, 10)\n(1, 2)\nCan't burn candle longer than burn_rate\n</code></pre>\n<p>That was the easier part. Let's figure out what times we're able to achieve with more than one candle.</p>\n<h4 id=\"lotsandlotsofwax\">Lots and lots of wax</h4>\n<p>Suppose now we have two candles that all have the same burn rate of $m$ minutes each. It is simple to see that we are able to achieve a maximum time of $2m$ minutes by using them in succession—that is, burning them one by one until we're done. In fact, these &quot;additive&quot; times are reached simply by adding any times $t_1$ and $t_2$ together such that $t_1, t_2 \\in S$, where $S = \\{\\frac mz \\mid z\\in\\mathbb{Z^+}\\}$ (the set of times possible with each candle of burn rate $m$). One can see that $\\lvert S \\rvert = \\infty$ because we haven't defined proper constraints for $z$. For our sake, we can define a maximum number of fires $e$ allowed for each candle (meaning no one candle can have more than $e$ fires ablaze at one time, which limits the magnitude of $S$ to a finite number). Furthermore, let's define $S_{m,e}$ to mean <strong>the set of times achievable with a single candle of burn rate $m$ and max fires of $e$</strong>:<br>\n$$<br>\nS_{m,e} = \\{\\frac mz \\mid z\\in\\mathbb{Z^+}, 1 \\leq z \\leq e \\}<br>\n$$<br>\nAs an example, set $m=60, e=3$. Thus, the two candles are able to produce the times in $S_{60,3}$ <em>individually</em>. This means that, by itself, any one of the two candles can produce any of these times in the set $S_{60,3} = \\{60,30,20\\}$. Utilizing both of them, however, produces a wider range of possible times.</p>\n<hr>\n<p>The set of possible times of using <em>both</em> candles is expanded because you have more choices as to how you go about lighting, splitting, and delaying each candle. One set of possibilities is the option of successively lighting each candle after the last one burns out. Let's call this set of times $T_{sc}$. In our example above, each candle is able to burn for either 60, 30, or 20 minutes each. We see that if we burn the first candle for 60 minutes, <em>then</em> burn the second for 60 minutes, we've produced a new possible time of 120 minutes. Each of the times in $S_{60,3}$ is added to all possible times also in the same set $S_{60,3}$. As such, we are left with $T_{sc}$ containing the set of numbers which result from the <a href=\"https://en.wikipedia.org/wiki/Minkowski_addition\">Minkowski addition</a> (or direct sum) of $S_{60,3}$ and itself. It's intuitive to see how the times form from successive burning, and we demonstrate it below with all possible cases of said process. Let the first and second candles, along with their remaining burn times, be $c_{1},c_{2},b_{1},b_{2}$, respectively.</p>\n<p>Successive burning:</p>\n<ul>\n<li>\n<p>(Case 1) $c_{1}$ burns for $b_{1}=60$ minutes, then</p>\n<ul>\n<li>(1A) $c_{2}$ burns for $b_{2}=60$ minutes $\\rightarrow b_{1}+ b_{2} =$ 120 minutes.</li>\n<li>(1B) $c_{2}$ burns for $b_{2}=30$ minutes $\\rightarrow b_{1}+ b_{2} =$ 90 minutes.</li>\n<li>(1C) $c_{2}$ burns for $b_{2}=20$ minutes $\\rightarrow b_{1}+ b_{2} =$ 80 minutes.</li>\n</ul>\n</li>\n<li>\n<p>(Case 2) $c_{1}$ burns for $b_{1}=30$ minutes, then</p>\n<ul>\n<li>(2A) $c_{2}$ burns for $b_{2}=60$ minutes $\\rightarrow b_{1}+ b_{2} =$ 90 minutes.</li>\n<li>(2B) $c_{2}$ burns for $b_{2}=30$ minutes $\\rightarrow b_{1}+ b_{2} =$ 60 minutes.</li>\n<li>(2C) $c_{2}$ burns for $b_{2}=20$ minutes $\\rightarrow b_{1}+ b_{2} =$ 50 minutes.</li>\n</ul>\n</li>\n<li>\n<p>(Case 3) $c_{1}$ burns for $b_{1}=20$ minutes, then</p>\n<ul>\n<li>(3A) $c_{2}$ burns for $b_{2}=60$ minutes $\\rightarrow b_{1}+ b_{2} =$ 80 minutes.</li>\n<li>(3B) $c_{2}$ burns for $b_{2}=30$ minutes $\\rightarrow b_{1}+ b_{2} =$ 50 minutes.</li>\n<li>(3C) $c_{2}$ burns for $b_{2}=20$ minutes $\\rightarrow b_{1}+ b_{2} =$ 40 minutes.</li>\n</ul>\n</li>\n</ul>\n<p>Thus, $T_{sc} = \\{120,90,80,60,50,40\\}$ given two candles, with $m=60, e=3$. The other option of discovering time possibilities is the idea of simultaneously burning the candles. This method is a bit trickier. Recall that towards the start of this post was a solution for 45 minutes that involved two candles: the first candle was lit on one end and the second was lit on both ends. Both burned for 30 minutes (until the second one burned out) and the first one was left with 30 remaining minutes of wax (30 minutes have also passed at this point). We ensured the remaining one had two fires ablaze and thus burned twice as fast with 30 minutes of fuel left, which means it burned for 15 minutes. The 30 minutes from the simultaneous burning and the 15 from the remainder burning produced 45 total minutes. This was possible because we were able to reduce the first candle's burn rate down by any attainable time of the second candle, and from there we solved the sub-problem of getting 15 minutes using an $m=30$ candle. Let $T_{sim}$ be the set of times that result from simultaneously burning both candles and adding on the time possibility set of the remaining candle. Each case of these simultaneously burnings are outline below.</p>\n<p>Simultaneous (then remainder) burning:</p>\n<ul>\n<li>\n<p>(Case 1) Light $c_{1}$ with 1 fire ($b_{1}=60$) along with</p>\n<ul>\n<li>(1A) $c_{2}$ with 1 fire ($b_{2}=60$) $\\rightarrow$ $c_{2}$ burns out; $b_{1}=0$ remains.\n<ul>\n<li>$b_{2} + S_{b_{1},e=3} = 60+\\{0\\} = \\{60\\}$</li>\n</ul>\n</li>\n<li>(1B) $c_{2}$ with 2 fires ($b_{2}=30$) $\\rightarrow$ $c_{2}$ burns out; $b_{1}=30$ remains.\n<ul>\n<li>$b_{2} + S_{b_{1},e=3} = 30+\\{30,15,10\\} = \\{60,45,40\\}$</li>\n</ul>\n</li>\n<li>(1C) $c_{2}$ with 3 fires ($b_{2}=20$) $\\rightarrow$ $c_{2}$ burns out; $b_{1}=40$ remains.\n<ul>\n<li>$b_{2} + S_{b_{1},e=3} = 20+\\{40,20,\\frac{40}3\\} = \\{60,40,33\\frac13\\}$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>(Case 2) Light $c_{1}$ with 2 fires ($b_{1}=30$) along with</p>\n<ul>\n<li>(2A) $c_{2}$ with 1 fire ($b_{2}=60$) $\\rightarrow$ same as case 1B.</li>\n<li>(2B) $c_{2}$ with 2 fires ($b_{2}=30$) $\\rightarrow$ $c_{2}$ burns out; $b_{1}=0$ remains.\n<ul>\n<li>$b_{2} + S_{b_{1},e=3} = 30+\\{0\\} = \\{30\\}$</li>\n</ul>\n</li>\n<li>(2C) $c_{2}$ with 3 fires ($b_{2}=20$) $\\rightarrow$ $c_{2}$ burns out; $b_{1}=10$ remains.\n<ul>\n<li>$b_{2} + S_{b_{1},e=3} = 20+\\{10,5,\\frac{10}3\\} = \\{30,25,23\\frac13\\}$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>(Case 3) Light $c_{1}$ with 3 fires ($b_{1}=20$) along with</p>\n<ul>\n<li>(3A) $c_{2}$ with 1 fire ($b_{2}=60$) $\\rightarrow$ same as case 1C.</li>\n<li>(3B) $c_{2}$ with 2 fires ($b_{2}=30$) $\\rightarrow$ same as case 2C.</li>\n<li>(3C) $c_{2}$ with 3 fires ($b_{2}=20$) $\\rightarrow$ $c_{2}$ burns out; $b_{1}=0$ remains.\n<ul>\n<li>$b_{2} + S_{b_{1},e=3} = 20+\\{0\\} = \\{20\\}$</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Thus, $T_{sim} = \\{60,45,40,33\\frac13,30,25,23\\frac13,20\\}$ given two candles, with $m=60, e=3$. We have then that given these two candles, we're about to produce the final set of times $T$:<br>\n$$<br>\nT = S_{60,3} \\cup T_{sc} \\cup T_{sim}=\\{120,90,80,60,50,45,40,33\\frac13,30,25,23\\frac13,20\\}<br>\n$$<br>\nNow, what would happen with three candles? The short story is, the successive times of three candles with the same burn rate and max fires is simply the direct sum of our previous times of 2 candles $T$ with another $S_{60,3}$. Similarly, the possible simultaneous times of this group would utilize the same procedure we used for $S_{60,3}$, except now we find all possible cases using the expanded set of times $T$ instead. Let's define a few functions back in Python to help us figure out all the times given a number of <code>candles</code>, a <code>burn_rate</code>, and <code>max_fires</code>. The function <code>times_succession()</code> accepts two sets and returns the direct sum of those two sets. The function <code>times_simul()</code> accepts two sets and max fires, and returns the set of times as described in our simultaneous and remainder burning above. <code>times_of_one_candle()</code> simply returns the set of times possible with one candle given its burn rate and max fires.</p>\n<pre><code class=\"language-language-python\">def times_succession(set_one, set_two):\n    t_sc = set([])\n\n    for x in set_one:\n        for y in set_two:\n            t_sc |= {round(x + y, 4)}\n\n    return t_sc\n\n\ndef times_simul(set_one, set_two, max_fires):\n    t_sim = set([])\n\n    for x in set_one:\n        for y in set_two:\n            if x &gt;= y:\n                remaining_time = x - y\n                t = times_succession({round(y, 4)}, times_of_one_candle(remaining_time, max_fires))\n                t_sim |= t\n\n    return t_sim\n\n\ndef times_of_one_candle(burn_rate, max_fires):\n    s = set([])\n\n    for x in range(1, max_fires + 1):\n        s |= {burn_rate / x}\n\n    return s\n</code></pre>\n<p>We now have functions that return all the subsets needed for our equation in order to find all the possible sets given the correct parameters. Let's write a function <code>all_times()</code>, which takes in our three arguments <code>candles</code>, <code>burn_rate</code>, and <code>max_fires</code> and calls our helper functions to return the set of all times that we are able to achieve with these constraints.</p>\n<pre><code class=\"language-language-python\">def all_times(candles, burn_rate, max_fires):\n    if candles == 0 or burn_rate == 0 or max_fires == 0:\n        return set([])\n    if candles == 1:\n        return times_of_one_candle(burn_rate, max_fires)\n\n    times = set([])\n\n    s = times_of_one_candle(burn_rate, max_fires)\n    times |= s\n\n    for c in range(1, candles):\n        t_sc = times_succession(times, s)\n        t_sim = times_simul(times, s, max_fires)\n        times |= (t_sc | t_sim)\n\n    return times\n\ns = sorted(all_times(2, 60, 3), reverse=True)\nprint('{}\\nMagnitude: {}'.format(s, len(s)))\n    \ns = sorted(all_times(3, 60, 4), reverse=True)\nprint('{}\\nMagnitude: {}'.format(s, len(s)))\n    \ns = sorted(all_times(4, 100, 5), reverse=True)\nprint('{}\\nMagnitude: {}'.format(s, len(s)))\n    \ns = sorted(all_times(5, 100, 6), reverse=True)\nprint('{}\\nMagnitude: {}'.format(s, len(s)))\n    \ns = sorted(all_times(6, 200, 5), reverse=True)\nprint('{}\\nMagnitude: {}'.format(s, len(s)))\n</code></pre>\n<pre><code class=\"language-language-none\">[120.0, 90.0, 80.0, 60.0, 50.0, 45.0, 40.0, 33.3333, 30.0, 25.0, 23.3333, 20.0]\nMagnitude: 12\n[180.0, 150.0, 140.0, 120.0, 110.0, 105.0, 100.0, 93.3333, 90.0, 85.0, 83.3333, ...]\nMagnitude: 100\n[400.0, 350.0, 333.3333, 325.0, 300.0, 283.3333, 275.0, 266.6667, 266.6666, ...]\nMagnitude: 2414\n[500.0, 450.0, 433.3333, 425.0, 420.0, 400.0, 383.3333, 375.0, 370.0, 366.6667, ...]\nMagnitude: 30885\n[1200.0, 1100.0, 1066.6667, 1050.0, 1040.0, 1000.0, 966.6667, 950.0, 940.0, ...]\nMagnitude: 75430\n</code></pre>\n<p>The magnitude of each set displayed is simply the number of possible times. At this point, it's trivial to search for a time goal by reversing the process such that the script gives us <code>candles</code>, <code>burn_rate</code>, and/or <code>max_fires</code> given an input time goal.</p>\n<p>Finally, it is also pretty trivial to imagine how many hours and chances ago I should have stopped trying to dive into this problem, but we both know those attempts were futile.</p>\n","comment_id":"5c5bbbc35d0d6b08c557fff6","plaintext":"The problems below were posed by my Design and Analysis of Algorithms \nprofessor. Although we did not spend much time on the solution or its\nimplications, I figured over-analyzing it might be in order if I wanted to read\nback on this in the future and think of the productivity wasted on this post.\n\nThe initial problem\nGiven a special candle of unknown length that burns up in one hour regardless of\nthe orientation it is placed in (i.e. whether the candle is lit upside down or\nright side up or some other degree of rotation), how can you use this candle as\na timer to know when 30 minutes have passed? The density of the candle's wax\nvaries along the whole length, so two equal lengths will burn up in different\ntimes (you aren't allowed to measure the length of the candle anyway). Assume\nthe wick is present on both ends of the candle (meaning you can light two fires\nat once), and that you are able to light a fire or split the candle with no loss\nof relative time. Remember: you need the timer to start immediately, so the goal\nis to use the candle as a timer, not to be left with a candle timer. This is a\nvariation of the burning rope problem\n[https://curiosity.com/topics/the-burning-rope-logic-puzzle/]  but uses the more\nenvironmentally conscious alternative to setting ropes on fire: burning candles.\n\nThe initial solution\nLight both ends of the candle. It is trivial to see how we can measure 30\nminutes using a single candle and two fires. Regardless of how long the candle\nis, we simply need the information that the whole candle will burn in one hour;\nthis means that the amount of wax present is only able to fuel one hour of burn\ntime with one fire going. Thus, burning two fires using both ends of the candle\nmeans using the same amount of fuel but twice as fast. Therefore, once the two\nfires meet and the candle runs out of wax, 30 minutes have passed.\n\nBlackouts are inconvenient\nSay you found a stash of more one-hour candles. What if you had the same problem\nas above, but now wanted to measure 45 minutes? We already know how to achieve\n30 minutes using one candle, so going for 45 minutes with two candles should not\nbe a tall order. The solution is as follows: light the two ends of the first\ncandle as above, but also light one end of a second candle. Once the first\ncandle burns out in 30 minutes, we are left with 30 minutes remaining on the\nsecond burning candle. Light the unlit end in order to get this candle to use\nfuel twice as fast, so that it burns out in 15 minutes. This gives us 45 minutes\nof total light we wanted.\n\nWhat happens if we wanted to get 15 minutes using only one candle? Turns out,\nthis is the hardest of the problems encountered so far. Since we only have one\ncandle, it'd be impossible to get any amount of time less than 30 minutes\nwithout having to split the candle into two or more parts. Thus, the solution\nlies in breaking this one candle into two pieces of candle. The non-intuitive\npart of it all is that the length of the two pieces do not matter in this\nsolution. In fact, length does not play a role in finding the solution to any\namount of time, which is why the seemingly unknown length is irrelevant to the\nwhole thing. We now have two (unequal) child parts of the same candle. The first\nstep of the solution is to light both ends of both candles, so that there are 4\nfires burning at the same time. You can sort of see a pattern now: one fire\nequals an hour of light, two fires give half that time, etc. The caveat to\nburning four fires is knowing what to do after the first of the two pairs of\nfires burn out earlier than the other (which it will, as the two unequal pieces\nimply that one has to be shorter). The solution is simple: the moment the first\nchild candle burns out, take the other candle and split it into two child pieces\nagain, and make sure both ends are lit for each. Since we are assuming there is\nno wasted time in splitting candles and lighting fires, the candles will all\neventually burn out completely in 15 minutes. Simply explained, the whole candle\nwill burn out in 15 minutes because you will always have four fires burning\nsimultaneously. This is similar to the 30 minutes solution: at any time, your\ncandle will be burning two fires, so it runs out of fuel twice as fast. In this\nsolution, your candle is running out of fuel 4 times as fast, and therefore your\nfuel lasts a fourth of an hour. In general, if you had multiple children\ncandles, you split a remaining candle every time one of them burns out in order\nto maintain the same number of fires alive to consume the total fuel.\n\nThe table below shows the general pattern of parts and fires needed to achieve a\ngiven burning time in minutes for one candle. Parts, in this case, means the\nnumber of parts you are splitting the initial candle into, and does not account\nfor the times you recursively break up the child candles.\n\nParts\n Fires  \n Time\n 1\n 1  \n 60\n 1\n 2  \n 30\n 2\n 3  \n 20\n 2\n 4  \n 15\n 3\n 5  \n 12\n 3\n 6  \n 10\n What time is it?\nThe general equation for the number of fires $f$ needed to achieve a time $t$ in\nminutes is then simply $f=\\frac{60}t$. The number of parts $p$ needed given $f$\nis then $p=\\lceil\\frac{f}2 \\rceil$. Keep in mind that this equation is valid\nonly if we have one candle, and therefore $f\\in\\mathbb{Z^+}$. If such is the\ncase, then the only exact times we are able to achieve with one candle are the\nquotients of dividing 60 by any positive integer. We can say that given a candle\nthat normally burns (with a single flame) in $m$ minutes, the set of all\nsolutions are in $\\{\\frac mz \\mid z\\in\\mathbb{Z^+}\\}$. So, knowing how the\nsolution plays out, and how long one candle burns for, let's write a simple\nPython script to calculate how many parts the initial candle needs to be split\ninto, and how many fires need to be simultaneously lit in order to achieve a\ndesired time. We have two arguments to pass in: burn_rate  (the time it takes to\nburn the whole candle with a single fire) and target_time  (a time you'd like to\nwaste playing with candles). The program should output a tuple: the former\nnumber will be the parts to split into and the latter will be the number of\nfires to light between all those parts. These two pieces of information will get\nyou as close to your target_time  as possible without exceeding it. The code\nbelow demonstrates one way of achieving this.\n\nimport math\n\ndef candle_waster(burn_rate, target_time):\n  fires = math.ceil(burn_rate/target_time)\n  parts = math.ceil(fires/2)\n  if target_time > burn_rate:\n    return \"Can't burn candle longer than burn_rate\"\n  return parts, fires\n    \nprint(candle_waster(60,15))\nprint(candle_waster(30,5))\nprint(candle_waster(10,1))\nprint(candle_waster(5,3))\nprint(candle_waster(1,2))\n\n\n(2, 4)\n(3, 6)\n(5, 10)\n(1, 2)\nCan't burn candle longer than burn_rate\n\n\nThat was the easier part. Let's figure out what times we're able to achieve with\nmore than one candle.\n\nLots and lots of wax\nSuppose now we have two candles that all have the same burn rate of $m$ minutes\neach. It is simple to see that we are able to achieve a maximum time of $2m$\nminutes by using them in succession—that is, burning them one by one until we're\ndone. In fact, these \"additive\" times are reached simply by adding any times\n$t_1$ and $t_2$ together such that $t_1, t_2 \\in S$, where $S = \\{\\frac mz \\mid\nz\\in\\mathbb{Z^+}\\}$ (the set of times possible with each candle of burn rate\n$m$). One can see that $\\lvert S \\rvert = \\infty$ because we haven't defined\nproper constraints for $z$. For our sake, we can define a maximum number of\nfires $e$ allowed for each candle (meaning no one candle can have more than $e$\nfires ablaze at one time, which limits the magnitude of $S$ to a finite number).\nFurthermore, let's define $S_{m,e}$ to mean the set of times achievable with a\nsingle candle of burn rate $m$ and max fires of $e$:\n$$\nS_{m,e} = \\{\\frac mz \\mid z\\in\\mathbb{Z^+}, 1 \\leq z \\leq e \\}\n$$\nAs an example, set $m=60, e=3$. Thus, the two candles are able to produce the\ntimes in $S_{60,3}$ individually. This means that, by itself, any one of the two\ncandles can produce any of these times in the set $S_{60,3} = \\{60,30,20\\}$.\nUtilizing both of them, however, produces a wider range of possible times.\n\n\n--------------------------------------------------------------------------------\n\nThe set of possible times of using both  candles is expanded because you have\nmore choices as to how you go about lighting, splitting, and delaying each\ncandle. One set of possibilities is the option of successively lighting each\ncandle after the last one burns out. Let's call this set of times $T_{sc}$. In\nour example above, each candle is able to burn for either 60, 30, or 20 minutes\neach. We see that if we burn the first candle for 60 minutes, then  burn the\nsecond for 60 minutes, we've produced a new possible time of 120 minutes. Each\nof the times in $S_{60,3}$ is added to all possible times also in the same set\n$S_{60,3}$. As such, we are left with $T_{sc}$ containing the set of numbers\nwhich result from the Minkowski addition\n[https://en.wikipedia.org/wiki/Minkowski_addition]  (or direct sum) of\n$S_{60,3}$ and itself. It's intuitive to see how the times form from successive\nburning, and we demonstrate it below with all possible cases of said process.\nLet the first and second candles, along with their remaining burn times, be\n$c_{1},c_{2},b_{1},b_{2}$, respectively.\n\nSuccessive burning:\n\n * (Case 1) $c_{1}$ burns for $b_{1}=60$ minutes, then\n   \n    * (1A) $c_{2}$ burns for $b_{2}=60$ minutes $\\rightarrow b_{1}+ b_{2} =$ 120\n      minutes.\n    * (1B) $c_{2}$ burns for $b_{2}=30$ minutes $\\rightarrow b_{1}+ b_{2} =$ 90\n      minutes.\n    * (1C) $c_{2}$ burns for $b_{2}=20$ minutes $\\rightarrow b_{1}+ b_{2} =$ 80\n      minutes.\n   \n   \n * (Case 2) $c_{1}$ burns for $b_{1}=30$ minutes, then\n   \n    * (2A) $c_{2}$ burns for $b_{2}=60$ minutes $\\rightarrow b_{1}+ b_{2} =$ 90\n      minutes.\n    * (2B) $c_{2}$ burns for $b_{2}=30$ minutes $\\rightarrow b_{1}+ b_{2} =$ 60\n      minutes.\n    * (2C) $c_{2}$ burns for $b_{2}=20$ minutes $\\rightarrow b_{1}+ b_{2} =$ 50\n      minutes.\n   \n   \n * (Case 3) $c_{1}$ burns for $b_{1}=20$ minutes, then\n   \n    * (3A) $c_{2}$ burns for $b_{2}=60$ minutes $\\rightarrow b_{1}+ b_{2} =$ 80\n      minutes.\n    * (3B) $c_{2}$ burns for $b_{2}=30$ minutes $\\rightarrow b_{1}+ b_{2} =$ 50\n      minutes.\n    * (3C) $c_{2}$ burns for $b_{2}=20$ minutes $\\rightarrow b_{1}+ b_{2} =$ 40\n      minutes.\n   \n   \n\nThus, $T_{sc} = \\{120,90,80,60,50,40\\}$ given two candles, with $m=60, e=3$. The\nother option of discovering time possibilities is the idea of simultaneously\nburning the candles. This method is a bit trickier. Recall that towards the\nstart of this post was a solution for 45 minutes that involved two candles: the\nfirst candle was lit on one end and the second was lit on both ends. Both burned\nfor 30 minutes (until the second one burned out) and the first one was left with\n30 remaining minutes of wax (30 minutes have also passed at this point). We\nensured the remaining one had two fires ablaze and thus burned twice as fast\nwith 30 minutes of fuel left, which means it burned for 15 minutes. The 30\nminutes from the simultaneous burning and the 15 from the remainder burning\nproduced 45 total minutes. This was possible because we were able to reduce the\nfirst candle's burn rate down by any attainable time of the second candle, and\nfrom there we solved the sub-problem of getting 15 minutes using an $m=30$\ncandle. Let $T_{sim}$ be the set of times that result from simultaneously\nburning both candles and adding on the time possibility set of the remaining\ncandle. Each case of these simultaneously burnings are outline below.\n\nSimultaneous (then remainder) burning:\n\n * (Case 1) Light $c_{1}$ with 1 fire ($b_{1}=60$) along with\n   \n    * (1A) $c_{2}$ with 1 fire ($b_{2}=60$) $\\rightarrow$ $c_{2}$ burns out;\n      $b_{1}=0$ remains. * $b_{2} + S_{b_{1},e=3} = 60+\\{0\\} = \\{60\\}$\n      \n      \n    * (1B) $c_{2}$ with 2 fires ($b_{2}=30$) $\\rightarrow$ $c_{2}$ burns out;\n      $b_{1}=30$ remains. * $b_{2} + S_{b_{1},e=3} = 30+\\{30,15,10\\} =\n         \\{60,45,40\\}$\n      \n      \n    * (1C) $c_{2}$ with 3 fires ($b_{2}=20$) $\\rightarrow$ $c_{2}$ burns out;\n      $b_{1}=40$ remains. * $b_{2} + S_{b_{1},e=3} = 20+\\{40,20,\\frac{40}3\\} =\n         \\{60,40,33\\frac13\\}$\n      \n      \n   \n   \n * (Case 2) Light $c_{1}$ with 2 fires ($b_{1}=30$) along with\n   \n    * (2A) $c_{2}$ with 1 fire ($b_{2}=60$) $\\rightarrow$ same as case 1B.\n    * (2B) $c_{2}$ with 2 fires ($b_{2}=30$) $\\rightarrow$ $c_{2}$ burns out;\n      $b_{1}=0$ remains. * $b_{2} + S_{b_{1},e=3} = 30+\\{0\\} = \\{30\\}$\n      \n      \n    * (2C) $c_{2}$ with 3 fires ($b_{2}=20$) $\\rightarrow$ $c_{2}$ burns out;\n      $b_{1}=10$ remains. * $b_{2} + S_{b_{1},e=3} = 20+\\{10,5,\\frac{10}3\\} =\n         \\{30,25,23\\frac13\\}$\n      \n      \n   \n   \n * (Case 3) Light $c_{1}$ with 3 fires ($b_{1}=20$) along with\n   \n    * (3A) $c_{2}$ with 1 fire ($b_{2}=60$) $\\rightarrow$ same as case 1C.\n    * (3B) $c_{2}$ with 2 fires ($b_{2}=30$) $\\rightarrow$ same as case 2C.\n    * (3C) $c_{2}$ with 3 fires ($b_{2}=20$) $\\rightarrow$ $c_{2}$ burns out;\n      $b_{1}=0$ remains. * $b_{2} + S_{b_{1},e=3} = 20+\\{0\\} = \\{20\\}$\n      \n      \n   \n   \n\nThus, $T_{sim} = \\{60,45,40,33\\frac13,30,25,23\\frac13,20\\}$ given two candles,\nwith $m=60, e=3$. We have then that given these two candles, we're about to\nproduce the final set of times $T$:\n$$\nT = S_{60,3} \\cup T_{sc} \\cup\nT_{sim}=\\{120,90,80,60,50,45,40,33\\frac13,30,25,23\\frac13,20\\}\n$$\nNow, what would happen with three candles? The short story is, the successive\ntimes of three candles with the same burn rate and max fires is simply the\ndirect sum of our previous times of 2 candles $T$ with another $S_{60,3}$.\nSimilarly, the possible simultaneous times of this group would utilize the same\nprocedure we used for $S_{60,3}$, except now we find all possible cases using\nthe expanded set of times $T$ instead. Let's define a few functions back in\nPython to help us figure out all the times given a number of candles, a \nburn_rate, and max_fires. The function times_succession()  accepts two sets and\nreturns the direct sum of those two sets. The function times_simul()  accepts\ntwo sets and max fires, and returns the set of times as described in our\nsimultaneous and remainder burning above. times_of_one_candle()  simply returns\nthe set of times possible with one candle given its burn rate and max fires.\n\ndef times_succession(set_one, set_two):\n    t_sc = set([])\n\n    for x in set_one:\n        for y in set_two:\n            t_sc |= {round(x + y, 4)}\n\n    return t_sc\n\n\ndef times_simul(set_one, set_two, max_fires):\n    t_sim = set([])\n\n    for x in set_one:\n        for y in set_two:\n            if x >= y:\n                remaining_time = x - y\n                t = times_succession({round(y, 4)}, times_of_one_candle(remaining_time, max_fires))\n                t_sim |= t\n\n    return t_sim\n\n\ndef times_of_one_candle(burn_rate, max_fires):\n    s = set([])\n\n    for x in range(1, max_fires + 1):\n        s |= {burn_rate / x}\n\n    return s\n\n\nWe now have functions that return all the subsets needed for our equation in\norder to find all the possible sets given the correct parameters. Let's write a\nfunction all_times(), which takes in our three arguments candles, burn_rate, and\n max_fires  and calls our helper functions to return the set of all times that\nwe are able to achieve with these constraints.\n\ndef all_times(candles, burn_rate, max_fires):\n    if candles == 0 or burn_rate == 0 or max_fires == 0:\n        return set([])\n    if candles == 1:\n        return times_of_one_candle(burn_rate, max_fires)\n\n    times = set([])\n\n    s = times_of_one_candle(burn_rate, max_fires)\n    times |= s\n\n    for c in range(1, candles):\n        t_sc = times_succession(times, s)\n        t_sim = times_simul(times, s, max_fires)\n        times |= (t_sc | t_sim)\n\n    return times\n\ns = sorted(all_times(2, 60, 3), reverse=True)\nprint('{}\\nMagnitude: {}'.format(s, len(s)))\n    \ns = sorted(all_times(3, 60, 4), reverse=True)\nprint('{}\\nMagnitude: {}'.format(s, len(s)))\n    \ns = sorted(all_times(4, 100, 5), reverse=True)\nprint('{}\\nMagnitude: {}'.format(s, len(s)))\n    \ns = sorted(all_times(5, 100, 6), reverse=True)\nprint('{}\\nMagnitude: {}'.format(s, len(s)))\n    \ns = sorted(all_times(6, 200, 5), reverse=True)\nprint('{}\\nMagnitude: {}'.format(s, len(s)))\n\n\n[120.0, 90.0, 80.0, 60.0, 50.0, 45.0, 40.0, 33.3333, 30.0, 25.0, 23.3333, 20.0]\nMagnitude: 12\n[180.0, 150.0, 140.0, 120.0, 110.0, 105.0, 100.0, 93.3333, 90.0, 85.0, 83.3333, ...]\nMagnitude: 100\n[400.0, 350.0, 333.3333, 325.0, 300.0, 283.3333, 275.0, 266.6667, 266.6666, ...]\nMagnitude: 2414\n[500.0, 450.0, 433.3333, 425.0, 420.0, 400.0, 383.3333, 375.0, 370.0, 366.6667, ...]\nMagnitude: 30885\n[1200.0, 1100.0, 1066.6667, 1050.0, 1040.0, 1000.0, 966.6667, 950.0, 940.0, ...]\nMagnitude: 75430\n\n\nThe magnitude of each set displayed is simply the number of possible times. At\nthis point, it's trivial to search for a time goal by reversing the process such\nthat the script gives us candles, burn_rate, and/or max_fires  given an input\ntime goal.\n\nFinally, it is also pretty trivial to imagine how many hours and chances ago I\nshould have stopped trying to dive into this problem, but we both know those\nattempts were futile.","feature_image":"/content/images/2019/02/candles.png","featured":1,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2019-02-07T05:01:55.000Z","created_by":"1","updated_at":"2019-02-17T09:55:52.000Z","updated_by":"1","published_at":"2019-02-07T05:04:26.000Z","published_by":"1","custom_excerpt":null,"codeinjection_head":"","codeinjection_foot":"","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null}],"posts_authors":[{"id":"5be78bb59686370eba85dc55","post_id":"5be78bb59686370eba85dc50","author_id":"1","sort_order":0},{"id":"5be78bb59686370eba85dc5a","post_id":"5be78bb59686370eba85dc51","author_id":"1","sort_order":0},{"id":"5c5bbbc35d0d6b08c557fff7","post_id":"5c5bbbc35d0d6b08c557fff6","author_id":"1","sort_order":0}],"posts_tags":[{"id":"5be78bb59686370eba85dc52","post_id":"5be78bb59686370eba85dc50","tag_id":"5be78bb49686370eba85dc49","sort_order":0},{"id":"5be78bb59686370eba85dc53","post_id":"5be78bb59686370eba85dc50","tag_id":"5be78bb49686370eba85dc4a","sort_order":1},{"id":"5be78bb59686370eba85dc54","post_id":"5be78bb59686370eba85dc50","tag_id":"5be78bb49686370eba85dc4b","sort_order":2},{"id":"5be78bb59686370eba85dc56","post_id":"5be78bb59686370eba85dc51","tag_id":"5be78bb49686370eba85dc4c","sort_order":0},{"id":"5be78bb59686370eba85dc57","post_id":"5be78bb59686370eba85dc51","tag_id":"5be78bb49686370eba85dc4d","sort_order":1},{"id":"5be78bb59686370eba85dc58","post_id":"5be78bb59686370eba85dc51","tag_id":"5be78bb49686370eba85dc4e","sort_order":2},{"id":"5be78bb59686370eba85dc59","post_id":"5be78bb59686370eba85dc51","tag_id":"5be78bb49686370eba85dc4f","sort_order":3},{"id":"5c5bbc515d0d6b08c557fffc","post_id":"5c5bbbc35d0d6b08c557fff6","tag_id":"5be78bb49686370eba85dc4c","sort_order":1},{"id":"5c5bbc515d0d6b08c557fffd","post_id":"5c5bbbc35d0d6b08c557fff6","tag_id":"5c5bbc515d0d6b08c557fffa","sort_order":0},{"id":"5c5bbc515d0d6b08c557fffe","post_id":"5c5bbbc35d0d6b08c557fff6","tag_id":"5c5bbc515d0d6b08c557fffb","sort_order":2}],"roles":[{"id":"5be33e8f2ec3980b24cfe9d1","name":"Administrator","description":"Administrators","created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9d2","name":"Editor","description":"Editors","created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9d3","name":"Author","description":"Authors","created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9d4","name":"Contributor","description":"Contributors","created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9d5","name":"Owner","description":"Blog Owner","created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"},{"id":"5be33e8f2ec3980b24cfe9d6","name":"Admin Integration","description":"External Apps","created_at":"2018-11-07T19:35:43.000Z","created_by":"1","updated_at":"2018-11-07T19:35:43.000Z","updated_by":"1"}],"roles_users":[{"id":"5be33e912ec3980b24cfea17","role_id":"5be33e8f2ec3980b24cfe9d3","user_id":"5951f5fca366002ebd5dbef7"},{"id":"5be33e922ec3980b24cfeae5","role_id":"5be33e8f2ec3980b24cfe9d5","user_id":"1"},{"id":"5be78bb49686370eba85dc43","role_id":"5be33e8f2ec3980b24cfe9d3","user_id":"5be78bb49686370eba85dc42"}],"settings":[{"id":"5be33e932ec3980b24cfeae6","key":"db_hash","value":"72766d80-efff-42d8-be61-bb217ef23760","type":"core","created_at":"2018-11-07T19:35:47.000Z","created_by":"1","updated_at":"2018-11-07T19:35:47.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeae7","key":"next_update_check","value":"1551329771","type":"core","created_at":"2018-11-07T19:35:47.000Z","created_by":"1","updated_at":"2019-02-27T04:56:10.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeae8","key":"notifications","value":"[{\"dismissible\":true,\"location\":\"bottom\",\"status\":\"alert\",\"id\":\"2ac05f00-39cd-11e9-bfd9-8dae19ff968c\",\"custom\":false,\"createdAt\":\"2019-02-26T13:48:15.000Z\",\"type\":\"info\",\"top\":false,\"message\":\"Ghost <a href=\\\"https://github.com/TryGhost/Ghost/releases\\\">2.16.1</a> has been released, <a href=\\\"https://ghost.org/update/?v=2.5.0\\\">click here</a> to upgrade.\",\"seen\":false,\"addedAt\":\"2019-02-27T04:56:10.788Z\"}]","type":"core","created_at":"2018-11-07T19:35:47.000Z","created_by":"1","updated_at":"2019-02-27T04:56:10.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeae9","key":"session_secret","value":"ea1be4357aef2b728fb1366764d2d205e9b394aabd465b7c10b30c3eaed3d825","type":"core","created_at":"2018-11-07T19:35:47.000Z","created_by":"1","updated_at":"2018-11-07T19:35:47.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeaea","key":"title","value":"David Chen","type":"blog","created_at":"2017-05-24T09:16:35.000Z","created_by":"1","updated_at":"2017-12-28T21:41:02.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeaeb","key":"description","value":"Softwhere and when you need it.","type":"blog","created_at":"2017-05-24T09:16:35.000Z","created_by":"1","updated_at":"2018-11-11T01:55:13.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeaec","key":"logo","value":"","type":"blog","created_at":"2017-05-24T09:16:35.000Z","created_by":"1","updated_at":"2017-12-28T21:41:02.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeaed","key":"cover_image","value":"/content/images/2018/11/download-1.jpg","type":"blog","created_at":"2017-05-24T09:16:35.000Z","created_by":"1","updated_at":"2018-11-11T02:04:19.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeaee","key":"icon","value":"","type":"blog","created_at":"2017-12-14T10:00:26.000Z","created_by":"1","updated_at":"2017-12-14T10:00:26.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeaef","key":"default_locale","value":"en","type":"blog","created_at":"2017-12-14T10:00:26.000Z","created_by":"1","updated_at":"2017-12-14T10:00:26.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeaf0","key":"active_timezone","value":"America/New_York","type":"blog","created_at":"2017-05-24T09:16:35.000Z","created_by":"1","updated_at":"2017-12-28T21:41:02.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeaf1","key":"force_i18n","value":"true","type":"blog","created_at":"2017-12-14T10:00:26.000Z","created_by":"1","updated_at":"2017-12-14T10:00:26.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeaf3","key":"amp","value":"true","type":"blog","created_at":"2017-05-24T09:16:35.000Z","created_by":"1","updated_at":"2017-12-28T21:41:02.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeaf4","key":"ghost_head","value":"","type":"blog","created_at":"2017-05-24T09:16:35.000Z","created_by":"1","updated_at":"2017-12-28T21:41:02.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeaf5","key":"ghost_foot","value":"<script type=\"text/javascript\" async src=\"//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\">\nMathJax.Hub.Config({\n    tex2jax: {\n        inlineMath: [[\"$\", \"$\"], [\"\\\\(\", \"\\\\)\"]],\n        processEscapes: true\n    }\n});\n</script>","type":"blog","created_at":"2017-05-24T09:16:35.000Z","created_by":"1","updated_at":"2019-02-07T04:59:55.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeaf6","key":"facebook","value":"","type":"blog","created_at":"2017-05-24T09:16:35.000Z","created_by":"1","updated_at":"2017-12-28T21:41:02.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeaf7","key":"twitter","value":"","type":"blog","created_at":"2017-05-24T09:16:35.000Z","created_by":"1","updated_at":"2017-12-28T21:41:02.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeaf8","key":"labs","value":"{\"publicAPI\":true}","type":"blog","created_at":"2017-05-24T09:16:35.000Z","created_by":"1","updated_at":"2017-12-28T21:41:02.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeaf9","key":"navigation","value":"[]","type":"blog","created_at":"2017-05-24T09:16:35.000Z","created_by":"1","updated_at":"2017-12-28T21:41:02.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeafa","key":"slack","value":"[]","type":"blog","created_at":"2017-05-24T09:16:35.000Z","created_by":"1","updated_at":"2018-11-11T01:55:13.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeafb","key":"unsplash","value":"{\"isActive\":true}","type":"blog","created_at":"2017-12-14T10:00:26.000Z","created_by":"1","updated_at":"2017-12-28T21:39:57.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeafc","key":"active_theme","value":"casper","type":"theme","created_at":"2018-11-07T19:35:47.000Z","created_by":"1","updated_at":"2018-11-07T19:35:47.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeafd","key":"active_apps","value":"[]","type":"app","created_at":"2017-12-14T10:00:26.000Z","created_by":"1","updated_at":"2017-12-14T10:00:26.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeafe","key":"installed_apps","value":"[]","type":"app","created_at":"2017-12-14T10:00:26.000Z","created_by":"1","updated_at":"2017-12-14T10:00:26.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeaff","key":"is_private","value":"false","type":"private","created_at":"2017-05-24T09:16:35.000Z","created_by":"1","updated_at":"2017-12-28T21:41:02.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeb00","key":"password","value":"","type":"private","created_at":"2017-05-24T09:16:35.000Z","created_by":"1","updated_at":"2017-12-28T21:41:02.000Z","updated_by":"1"},{"id":"5be33e932ec3980b24cfeb01","key":"public_hash","value":"ac2805ef8e0838ce91ad23ca4d220e","type":"private","created_at":"2017-12-14T10:00:26.000Z","created_by":"1","updated_at":"2017-12-14T10:00:26.000Z","updated_by":"1"}],"subscribers":[],"tags":[{"id":"5be78bb49686370eba85dc49","name":"facebook","slug":"facebook","description":null,"feature_image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2017-06-08T18:34:00.000Z","created_by":"1","updated_at":"2018-02-18T09:42:53.000Z","updated_by":"1"},{"id":"5be78bb49686370eba85dc4a","name":"gaming","slug":"gaming","description":null,"feature_image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2017-06-08T18:34:00.000Z","created_by":"1","updated_at":"2018-02-18T09:42:53.000Z","updated_by":"1"},{"id":"5be78bb49686370eba85dc4b","name":"xhr","slug":"xhr","description":null,"feature_image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2017-06-08T18:34:00.000Z","created_by":"1","updated_at":"2018-02-18T09:42:53.000Z","updated_by":"1"},{"id":"5be78bb49686370eba85dc4c","name":"python","slug":"python","description":null,"feature_image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2017-06-08T18:49:27.000Z","created_by":"1","updated_at":"2017-12-28T21:41:02.000Z","updated_by":"1"},{"id":"5be78bb49686370eba85dc4d","name":"selenium","slug":"selenium","description":null,"feature_image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2017-06-08T18:49:27.000Z","created_by":"1","updated_at":"2017-12-28T21:41:02.000Z","updated_by":"1"},{"id":"5be78bb49686370eba85dc4e","name":"profiler","slug":"profiler","description":null,"feature_image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2017-06-08T18:49:27.000Z","created_by":"1","updated_at":"2017-12-28T21:41:02.000Z","updated_by":"1"},{"id":"5be78bb49686370eba85dc4f","name":"javascript","slug":"javascript","description":null,"feature_image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2017-06-08T18:49:27.000Z","created_by":"1","updated_at":"2017-12-28T21:41:02.000Z","updated_by":"1"},{"id":"5c5bbc515d0d6b08c557fffa","name":"algorithms","slug":"algorithms","description":null,"feature_image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2019-02-07T05:04:17.000Z","created_by":"1","updated_at":"2019-02-07T05:04:17.000Z","updated_by":"1"},{"id":"5c5bbc515d0d6b08c557fffb","name":"math","slug":"math","description":null,"feature_image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2019-02-07T05:04:17.000Z","created_by":"1","updated_at":"2019-02-07T05:04:17.000Z","updated_by":"1"}],"users":[{"id":"1","name":"David Chen","slug":"david","ghost_auth_access_token":null,"ghost_auth_id":null,"password":"$2a$10$9OiAQYlXv5eEENdJoox0FeeQkmB1fXFl2e18suI6dy/DC4aXZueXe","email":"chendavid96@gmail.com","profile_image":"/content/images/2018/11/sq-1.jpg","cover_image":"/content/images/2018/11/download.jpg","bio":null,"website":"http://chendav.id","location":null,"facebook":null,"twitter":null,"accessibility":null,"status":"active","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"tour":"[\"getting-started\"]","last_seen":"2019-02-07T04:51:51.000Z","created_at":"2018-11-07T19:35:44.000Z","created_by":"1","updated_at":"2019-02-07T04:51:51.000Z","updated_by":"1"},{"id":"5be78bb49686370eba85dc42","name":"Ghost","slug":"ghost-user","ghost_auth_access_token":null,"ghost_auth_id":null,"password":"$2a$10$yMgo7Ux6IiZNFcDawoFR2.yLF/5DLD0KcsFZM8Mj32s.fXZtjzjoG","email":"ghost-author@example.com","profile_image":null,"cover_image":null,"bio":"You can delete this user to remove all the welcome posts","website":null,"location":null,"facebook":null,"twitter":null,"accessibility":null,"status":"locked","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"tour":null,"last_seen":null,"created_at":"2017-12-14T10:00:01.000Z","created_by":"5be78bb49686370eba85dc41","updated_at":"2017-12-14T10:00:01.000Z","updated_by":"5be78bb49686370eba85dc41"}],"webhooks":[]}}]}